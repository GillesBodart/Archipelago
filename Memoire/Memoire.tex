% format de la feuille
% taille police globale (pas les titres)
% recto (oneside) ou recto-verso (twoside)
% fleqn pour numéroter les équations à droite
% classe : article, book, report
\documentclass[a4paper,fleqn,12pt,oneside]{book}

% ---------------------------------------------------------------------------------------------------------
% LANGUES ET POLICE

\usepackage[francais]{babel} % langue principale : français
\usepackage[utf8]{inputenc} % encodage 
\usepackage[T1]{fontenc} % accents
\usepackage{lmodern} % police vectorielle
\usepackage{ulem} % souligner
\usepackage[usenames,dvipsnames,svgnames,table]{xcolor} % pour écrire en couleur 

% ---------------------------------------------------------------------------------------------------------
% CARACTERES SPECIAUX + MATH
\usepackage{csquotes} % beaux guillemets \enquote{texte}
\usepackage{amssymb} % symboles mathématiques
\usepackage{listings} % inclure du joli code
\usepackage{listingsutf8}
\usepackage{amsmath} % formules mathématiques, flèches etc
\usepackage{amsfonts} % fraktur etc. 
\newcolumntype{M}[1]{>{\raggedright}m{#1}}
\lstset{
  language=Java,
  basicstyle=\ttfamily,
  columns=fullflexible,
  frame=single,
  breaklines=true,
  postbreak=\mbox{\space},
  numbers=left,
  numberstyle=\tiny,
  showspaces=false,
  showtabs=false,
  showstringspaces=false,
  breakatwhitespace=true,
  commentstyle=\color{MidnightBlue},
  keywordstyle=\color{blue},
  stringstyle=\color{ForestGreen},
  moredelim=[il][\textcolor{gray}]{\$\$},
  moredelim=[is][\textcolor{gray}]{\%\%}{\%\%},
  literate=%
         {é}{{\'e}}1
         {è}{{\`e}}1
         {ú}{{\'u}}1   
         {ù}{{\`u}}1
         {Á}{{\'A}}1
         {É}{{\'E}}1
         {ê}{{\^e}}1
         {Ê}{{\^E}}1
         {œ}{{\oe}}1
         {â}{{\^a}}1
         {à}{{\`a}}1
}
\lstdefinelanguage{JavaScript}{
  keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break},
  keywordstyle=\color{blue}\bfseries,
  ndkeywords={class, export, boolean, throw, implements, import, this},
  ndkeywordstyle=\color{darkgray}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{MidnightBlue}\ttfamily,
  stringstyle=\color{blue}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}
\lstdefinelanguage{json}{
    basicstyle=\normalfont\ttfamily,
    numbers=left,
    numberstyle=\scriptsize,
    stepnumber=1,
    numbersep=8pt,
    showstringspaces=false,
    breaklines=true,
    frame=lines,
    backgroundcolor=\color{white},
    literate=
     *{0}{{{\color{MidnightBlue}0}}}{1}
      {1}{{{\color{MidnightBlue}1}}}{1}
      {2}{{{\color{MidnightBlue}2}}}{1}
      {3}{{{\color{MidnightBlue}3}}}{1}
      {4}{{{\color{MidnightBlue}4}}}{1}
      {5}{{{\color{MidnightBlue}5}}}{1}
      {6}{{{\color{MidnightBlue}6}}}{1}
      {7}{{{\color{MidnightBlue}7}}}{1}
      {8}{{{\color{MidnightBlue}8}}}{1}
      {9}{{{\color{MidnightBlue}9}}}{1}
      {:}{{{\color{black}{:}}}}{1}
      {,}{{{\color{black}{,}}}}{1}
      {\{}{{{\color{ForestGreen}{\{}}}}{1}
      {\}}{{{\color{ForestGreen}{\}}}}}{1}
      {[}{{{\color{ForestGreen}{[}}}}{1}
      {]}{{{\color{ForestGreen}{]}}}}{1},
      literate=%
         {é}{{\'e}}1
         {è}{{\`e}}1
         {ú}{{\'u}}1
         {ù}{{\`u}}1
         {Á}{{\'A}}1
         {É}{{\'E}}1
         {ê}{{\^e}}1
         {Ê}{{\^E}}1
         {œ}{{\oe}}1
         {à}{{\`a}}1
}
% ---------------------------------------------------------------------------------------------------------
% LISTES
\usepackage{enumitem} % customiser les listes
%\frenchbsetup{StandardLists=true} % éviter les conflits avec enumitem
\setlist[itemize]{noitemsep, topsep=0pt}
\setlist[enumerate]{noitemsep, topsep=0pt}
\setlist[description]{noitemsep, topsep=0pt}
% ---------------------------------------------------------------------------------------------------------
% TABLEAUX ET FIGURES
\usepackage[sc,footnotesize]{caption} % légendes des tableaux et figures
\usepackage{subfig} % plusieurs figures côte à côte (subfloat)
\usepackage{longtable} % autoriser que les longs tableaux débordent sur plusieurs pages
\usepackage{multicol} % fusionner les colonnes dans un tableau
\usepackage{multirow} % fusionner les lignes dans un tableau
\usepackage{caption} % pour les légendes
\usepackage{slashbox} % pour les Tableaux comparatifs
\usepackage{graphicx} % insérer image
\usepackage{rotating}
\usepackage{epstopdf}
\usepackage{wrapfig}

\usepackage{fancybox}
\usepackage[Lenny]{fncychap}
\usepackage{csvsimple}
\graphicspath{{figures/}} % dossier dans lequel sont les images
%\usepackage{tikz} 	% outil de modélisation de formes

% ---------------------------------------------------------------------------------------------------------
% MISE EN PAGE 
\usepackage{lscape}
\usepackage{setspace}
\usepackage{verbatim}
\usepackage{url}
\bibliographystyle{plain}
\raggedbottom
% - Marges
\usepackage[top=2cm, bottom=2cm, left=2cm, right=2cm ]{geometry} % marges

% - Page style
\pagestyle{headings}

\DeclareUnicodeCharacter{00A0}{ }
% - Alinéas et espacements entre paragraphes
\usepackage{parskip}
\parskip = 10pt % espace
\parindent = 0pt % alinéa

% - Style des sections
\usepackage{titlesec}
\titleformat*{\section}{\Large\scshape}
\titleformat*{\subsection}{\large\scshape}
\titleformat*{\subsubsection}{\scshape}

\pagestyle{plain}
%---------------------------------------------------------------------------------------------------------
\selectlanguage{francais}
\author{Gilles Bodart}
\date{\today}
\title{Archipelago}
\begin{document}
\thispagestyle{empty}

\begin{center}
\textsc{Universit\'e de Namur}\\
Facult\'e d'informatique\\
Ann\'ee acad\'emique 2016--2017
\end{center}
\vspace{1.3cm}
\hspace{1.4cm}
\begin{center}
\fbox{
\begin{minipage}[c][5.4cm]{11cm}
\large
\begin{spacing}{1.2}
\begin{center}
\textbf{Archipelago : Un framework de persistance pour bases de données orientées graphe}
\\
\vspace{0.5cm}
Gilles Bodart
\end{center}
\end{spacing}
\end{minipage}
}
\end{center}


\vspace{0.5cm}
\begin{figure}[!h]
\centering\includegraphics[width=.4\textwidth]{figures/unamur.pdf}
\end{figure}

\normalsize


\vspace{0.5cm}
\begin{table}[!h]
\centering
  \begin{tabular}{ r l }
    Promoteur~: &  \rule{4cm}{0.1mm} {\small (Signature pour approbation du d\'ep\^ot - REE art. 40)}\\
    ~\underline& CLEVE Anthony \\\\
    Co-promoteur~: & LAMBIOTTE Renaud  \\
  \end{tabular}
\end{table}

\vspace{0.5cm}
\begin{center}
M\'emoire pr\'esent\'e en vue de l'obtention du grade de\\
Master en Sciences Informatiques.
\end{center}
\frontmatter
\vspace*{\stretch{1}}
\section*{Résumé}

Ce mémoire va se concentrer sur les implémentations de la théorie des graphes dans l'univers des bases de données, et le développement d'un framework Java présentant les qualités suivantes : l'abstraction, la simplification et la configurabilité. 

Archipelago est un framework dont le but est d'abstraire l'utilisation d'une base de données orientée graphe. Cet outil dans son  état actuel possède trois méthodes fonctionnelles ; à savoir : une méthode permettant de persister l'information, une autre permettant de lier deux nœuds à l'aide d'une relation et une dernière permettant de récupérer les différents objets dans la base de données. Elle peut effectuer ces trois opérations sur \texttt{Neo4J} et sur \texttt{OrientDB}.

Ce travail présente les points forts et les points faibles de l'implémentation de ce framework ainsi que des pistes d'amélioration pour une version ultérieure.

\quad \quad \underline{Mots-clés} : Framework, Base de données, Java, Graphes, Neo4J, OrientDB, Archipelago
\section*{Abstract}

In the scope of this master thesis, a new Java framework was developed to apply the graph theory to databases. This framework presents interesting qualities such as abstraction, simplification and configurability. 

The Archipelago framework abstracts graph-oriented databases. Currently, three methods are available: a first method that persists information, a second method that links nodes together with the help of a relation with or without properties and a third method that gives the ability to query databases and to retrieve persisted objects states. The framework can be used with both \texttt{Neo4J} and \texttt{OrientDB}.

This master thesis presents the framework implementation, its applications and its strengths and weaknesses.

\quad \quad \underline{Keywords} : Framework, databases, Java, Graphs, Neo4J, OrientDB, Archipelago
\vspace*{\stretch{1}}
\chapter*{Avant-propos}

\vspace*{\stretch{1}}
Je tiens à remercier tout particulièrement mes promoteurs, Messieurs A. CLEVE et \\R. LAMBIOTTE pour m'avoir autorisé à réaliser cette recherche et, conjointement, m'avoir soutenu dans le développement de celle-ci. Je les remercie aussi pour le temps consacré à la supervision de ce mémoire. 

Je remercie également les entreprises dans lesquelles j'ai travaillé, de m'avoir laissé l'opportunité de poursuivre le cursus universitaire.

Et, enfin, je tiens tout autant à remercier ma belle-mère C. NIGOT pour avoir pris du temps à me relire, ma collègue de classe L. CASTIN  et singulièrement ma compagne M. VAN CUTSEM qui m'a soutenu au quotidien pendant ces deux années, y compris pour sa patience actuelle durant sa grossesse en cours.

\vspace*{\stretch{1}}

\tableofcontents
\newpage
\chapter*{Glossaire :}
\begin{center}
\begin{tabular}[c]{ l p{14cm} }
 SQL  & \textbf{S}tructured \textbf{Q}uery \textbf{L}anguage \\ \hline
 NoSQL  & \textbf{N}ot \textbf{O}nly \textbf{SQL} \\ \hline
 SGBD  & \textbf{S}ystème de \textbf{g}estion de \textbf{b}ase de \textbf{d}onnées \\ \hline
 SGBDR  & \textbf{S}ystème de \textbf{g}estion de \textbf{b}ase de \textbf{d}onnées \textbf{r}elationnelles \\ \hline
 BDOG  & \textbf{B}ase de \textbf{d}onnées \textbf{o}rientée \textbf{g}raphe \\ \hline
 CRUD  & \textbf{C}reate \textbf{R}ead \textbf{U}pdate \textbf{D}elete : Ce sont les quatre opérations principales pour la persistance de données. \\ \hline
 JSON  & \textbf{J}ava\textbf{S}cript \textbf{O}bject \textbf{N}otation \\ \hline
 Vertex  & Sommet \\ \hline
 Edge  & Bord \\ \hline
 Cluster  & Littéralement grappe, cela représente en informatique un groupe d'éléments \\ \hline
 API  & \textbf{A}pplication \textbf{P}rogramming \textbf{I}nterface  \\ \hline
 REST  & \textbf{Re}presentational \textbf{S}tate \textbf{T}ransfer, style d'architecture pour les systèmes hypermédia distribués \\ \hline
 GDL & \textbf{G}arlic \textbf{D}efinition \textbf{L}anguage (variante de ODMG \cite{cattell1997object}) \\ \hline
 OO & \textbf{O}rienté \textbf{O}bjet \\ \hline
 POC & \textbf{P}roof \textbf{O}f \textbf{C}oncept \\ \hline
 YAML & \textbf{Y}et \textbf{A}nother \textbf{M}arkup \textbf{L}anguage \\ \hline
\end{tabular}
\end{center}
\clearpage
\setcounter{page}{1}
\mainmatter
\chapter{Introduction}

L'idée de réaliser ce mémoire nous est venue de notre travail en entreprise où nous utilisions un modèle de données très connectées. Nous avions comme mission de remanier ce modèle de données en le rendant totalement historisable. Pour ce faire, nous utilisions une base de données relationnelle mais ce choix nous posait problème, notamment au niveau des références circulaires. Ce genre de difficulté survient quand certains éléments identifiants se retrouvent dépendants d'eux-mêmes et forment ainsi un cycle\footnote{Une entreprise publiait un acte générant des évènements sur une entreprise (potentiellement la même)}. 

Nous recevions nos informations en provenance de plusieurs sources et chacune avait, bien entendu sa propre représentation. Un ensemble de méthodes devait donc être mis en place et maintenu pour faire correspondre ces modifications avec la représentation interne que nous avions de l'information. Toutes ces petites modifications rendaient le précédent modèle de moins en moins cohérent et stable. Il nous fallait donc penser à une structure évolutive permettant, pour ces demandes en provenance d'une source spécifique, ces ajouts qui alourdissaient les tables. 

Suite à ce questionnement, nous nous sommes interrogé d'une part, sur la pertinence de notre modèle car nous nous heurtions sans cesse à des difficultés multiples (niveau d'abstraction trop faible, changement d'identifiant lors de l'historisation, ...) et, d'autre part, à \enquote{l'entêtement} de l'utilisation de bases de données relationnelles. 

C'est alors que nous avons pensé à la mise en place d'un outil permettant d'éviter toutes les démarches auxquelles notre équipe s'était confrontée. Cette réflexion nous a fait découvrir les bases de données orientées graphe et les librairies qui permettent de les utiliser.

Nous avons pu observer que les bases de données orientées graphe (BDOG cf. glossaire) étaient de plus en plus nombreuses. Nous constations que chacune développait ses propres fonctionnalités. Nous avons dès lors voulu trouver un framework permettant de communiquer avec ces dernières tel que \enquote{JPA} le fait avec les bases de données relationnelles. A notre grande surprise, nous nous sommes aperçu que ce framework semblait ne pas exister.
\newpage
Le but de ce mémoire est précisément d'offrir une réponse à ce manque, en produisant un framework qui tentera de présenter les qualités suivantes :
\begin{itemize}
\item[•] \textbf{Abstraction} : L'utilisateur pourra employer ce framework sans même connaitre l'existence de librairies spécifiques.
\item[•] \textbf{Simplicité} : Les différentes méthodes seront explicites et faciles à intégrer dans une application existante.
\item[•] \textbf{Configurabilité} : Il réagira en fonction d'un fichier de configuration clair et simple.
\item[•] \textbf{\'Evolutivité} : Il permettra de faire évoluer la couche de persistance en fonction du modèle de données.
\end{itemize}

\begin{center}
Nous l'avons nommé \textbf{Archipelago}, traduction anglaise du mot archipel signifiant : \\ \enquote{\textit{Ensemble d'îles disposées en groupe et qui, de fait, forment une unité géographique}}\cite{linternaute}.
\end{center}
 
\part{État de l'art}

\chapter{L'évolution du NoSql}

Dans ce chapitre, nous allons retracer dans un premier temps l'historique des bases de données de type NoSQL. Dans un second temps, nous aborderons les différences entre les bases de données relationnelles et les bases de données orientées graphe. Enfin, au vu de ce que nous avons appris précédemment, nous spécifierons notre recherche par rapport à celles existantes et décrites dans la section \ref{NoSqlEvol}.

\section{L'historique}
\label{NoSqlEvol}

Un SGBD est par définition un ensemble de procédés permettant d'organiser et de stocker des informations (potentiellement de gros volumes). Si stocker et retrouver l'information est un des plus grands challenges d'un SGBD, une communauté de développeurs pense que ces systèmes devraient pouvoir offrir d'autres fonctionnalités \cite{coupaye1998modeles}.

La grande force des SGBDR\footnote{\textbf{S}ysteme de \textbf{G}estion de \textbf{B}ase de \textbf{D}onnées 
\textbf{R}elationnelles (cf. glossaire)} provient des fondements théoriques mis en place en 1970 par Edgar Frank Codd. IBM définit le langage \enquote{Structured Query Language} (SQL) pour utiliser ce système. Cette normalisation de la représentation de l'information génère un sentiment de sûreté pour les architectes de logiciels\cite{bruchez2016bases}.
 
A partir des années 1980, le modèle relationnel supplante les autres formes de structures de données.

Les évolutions logicielles suivant naturellement les évolutions matérielles avec la généralisation des interconnexions des réseaux, l'augmentation de la bande passante, la diminution du coût des machines, la miniaturisation des espaces de stockage, etc., de nouvelles opportunités apparaissent donc au XXI\up{e} siècle.

De nos jours, les unités de stockage sont de plus en plus accessibles au grand public. Les entreprises comme Google, Amazon, Facebook, Twitter, etc., sont tour à tour arrivées aux limites du modèle relationnel \cite{frishman1998comprehensive} comme la partition, l'évolutivité en fonction de la charge, etc. Que ce soit à cause de volumes astronomiques (plus de 100 pétaoctets) ou du nombre de requêtes par seconde, il faut donc développer une nouvelle façon de gérer les données.

Les différentes entreprises impliquées dans le développement des systèmes de gestion de base de données l'ont bien compris et recherchent des solutions alternatives telles que le NoSql\cite{nance2013nosql}. Ce mouvement NoSql pour \enquote{Not Only SQL} se base sur différentes représentations en provenance du théorème de CAP\footnote{Acronyme de \enquote{\textbf{C}oherence}, \enquote{\textbf{A}vailability} et \enquote{\textbf{P}artition tolerance}} aussi connu sous le nom de théorème de Brewer. Ce théorème prouve qu’il est impossible de garantir simultanément les trois contraintes suivantes : 
\begin{itemize}
\item[•]La cohérence
\item[•] La haute disponibilité
\item[•] La tolérance au partitionnement
\end{itemize}

Comme le mouvement
NoSQL veut promouvoir la haute disponibilité, il doit dès lors faire \enquote{l'impasse} soit sur la
cohérence, soit sur la tolérance au partitionnement. Cette possibilité de pouvoir choisir entre
trois éléments ne rassure toutefois pas les adeptes du relationnel \cite{di2012adoption}.

Par souci de classification, nous allons distinguer quatre usages principaux du NoSql:

\begin{itemize}
\item \textbf{Performances} : L'objectif du SGBD sera d'augmenter au maximum les performances de la manipulation des données. 
\item \textbf{Structures simples} : Pour s’affranchir de la rigidité du modèle relationnel, la structure sera généralement simplifiée en utilisant une représentation plus souple comme le JSON par exemple.
\item \textbf{Structures spécifiques} : Certains moteurs NoSql sont liés à des besoins spécifiques. La structure de représentation de données sera dès lors focalisée sur un cas d'utilisation.
\item \textbf{Volumétries} : Un des principaux aspects des SGBD NoSql est leur capacité à gérer la montée en charge des données. La distribution des traitements au travers de plusieurs clusters est un facteur essentiel dans la plupart des applications BigData.
\end{itemize} 

Nous allons distinguer aussi quatre grandes familles de représentation de schéma de données :

\begin{itemize}
\item \textbf{Document} : L'utilisation de formats spécifiques tels que le très répandu \enquote{JSON} permet de stocker les données sur base de fichier.
\item \textbf{Clé / Valeur }: Le système le plus simple, il manipule des paires de clé/valeur, ou accède à un élément en fonction d'une table de hachage.
\item \textbf{Colonne} : Inspirée de Google BigTable, la structure ressemble à la table relationnelle. On peut la comparer à une table de hachage qui va référencer une ou plusieurs colonnes.
\item \textbf{Graphe} : La famille Graphe se distingue du fait que les entités ne sont pas considérées comme des entités indépendantes, mais que la relation entre ces objets est tout aussi importante que le contenu.
\end{itemize} 

Les implémentations de bases de données de type graphe sont de plus en plus nombreuses. Les relations entre les éléments permettent de parcourir le graphe de manière très performante \cite{vicknair2010comparison}, le rendant de plus en plus intéressant pour les entreprises possédant des millions de données. Dès lors, l'utilisation de ce genre de SGBD est tout à fait recommandée pour des entreprises intéressées par les relations entre ces données, telles que des profils sociaux, des liens de cause à effet, des liens géographiques et bien d’autres encore \cite{infoqSite}\cite{NoSqlDef}\cite{bruchez2016bases}.

L'idée de mettre en place des méthodologies de simplification entre les applications et les bases de données n'est pas nouvelle. 
\newpage

En 1998, Tova Milo et Sagit Zohar ont proposé un système permettant de convertir des valeurs reçues depuis un fichier XML et son schéma DTD, en instance de OODB\cite{milo1998using}. 

\label{frameworksAnalyse}
En 1999, nous pouvons observer que la mise en place d'intergiciels \footnote{Logiciel permettant l'échange d'informations entre différentes applications informatiques. } permet de générer des \enquote{Wrappers} à l'aide du GDL\footnote{\textbf{G}arlic \textbf{D}efinition \textbf{L}anguage (cf. glossaire)}, et offre la possibilité d'abstraire l'information\cite{niswonger1999transforming}. Les \enquote{Wrappers} ainsi que les \enquote{Unwrappers} procurent aux frameworks d'automatisation un moyen de contrôler la structure de représentation des données. Grâce à ce contrôle, il est aisé de les utiliser et de les adapter pour les rendre conformes à une vue, une table, un schéma, ...  Ces procédés de \enquote{Wrapper} et \enquote{Unwrapper} ont constitué des solutions pour communiquer avec des systèmes dits \enquote{legacy}.

Nous pouvons nous apercevoir qu'il existe des systèmes de correspondance entre différents schémas de représentation. Par le biais d'XML, il est possible de faire transiter une information depuis un ancien schéma de données vers un nouveau\cite{miller2000schema}. 

Nous avons pu observer également qu'il existe des frameworks permettant de se protéger contre l'évolution du modèle de représentation. En effet, une étude montre que près de 70\% des requêtes\cite{curino2008schema} sont perdues à chaque nouvelle version de schéma. Pour pallier cette perte, certains frameworks génèrent des API Java sur base du schéma ER\footnote{\textbf{E}ntity \textbf{R}elation (cf. glossaire)} de la base de données\cite{cleve2010conceptual}.

\section{Le questionnement}

\subsection*{Pourquoi utiliser une BDOG plutôt qu'une BD relationnelle comme Oracle ou MySql ?}

L’utilisation des SGBD relationnelles pour tout type de problème est révolue. L'apparition de SGBD NoSQL spécifiques permet, dès à présent, une approche plus personnalisée. En effet, comme tout système, le relationnel a ses limites. L’approche actuelle des entreprises est davantage orientée \enquote{Big Data}; les entreprises veulent tout stocker afin d’avoir le plus d’informations possible\cite{lohr2012age}. Or comme le relationnel cadenasse les données dans une table préalablement définie, on se doit de tronquer l'information ou de mettre à jour le schéma de définition des tables. 

Dans une BDOG telle que Neo4J, nous pouvons ajouter toutes les informations que nous voulons sans condition préalable. Cette approche permet un meilleur contrôle de l'intégrité des données aux applications.

Si l'objectif de l'application est de représenter un système récursif, comme par exemple, une arborescence de fichiers, des données généalogiques, etc., le modèle relationnel se basera sur une table faisant référence à elle-même. L’utilisateur devra donc réaliser une jointure par profondeur. Si l’arborescence descend jusqu’à 15 niveaux, cela peut devenir problématique\cite{miller2013graph}. L'approche BDOG permet de parcourir une arborescence sans pour autant charger l'ensemble des nœuds ayant le même label. Dès lors, plus besoin de projection ensembliste pour pouvoir continuer le chemin.
\newpage
En relationnel, il existe de nombreux moyens d’historiser les données. Cependant, lorsque le schéma comprend des relations cycliques, cette opération devient plus complexe. L'utilisation d'une BDOG rend la démarche plus simple, il suffit de créer un nouveau nœud avec les anciennes données, de lier ce nœud avec une relation historique en y spécifiant la date de mise à jour, et ensuite de changer les valeurs du nœud référencé par le cycle. Ce procédé peut être mis au point dans n’importe quelle représentation et ne nécessite aucune refonte globale du modèle de données\cite{NoSQLVsSGBDR}\label{noSqlVSRel}.

\subsection*{Quelle est la différence entre une relation entre deux nœuds et une relation entre deux tables ?}
Les relations entre deux tables se font à l’aide de clés étrangères définies lors de la création du schéma de données. Elles apportent de l’information supplémentaire en permettant de réaliser des jointures entre plusieurs tables.

La relation dans les BDOG est une information à part entière, elle peut posséder autant de données que le nœud lui-même.  La force de ce genre de système est de pouvoir lier deux nœuds distincts par n’importe quelle relation et ce, à tout moment\cite{NoSQLVsSGBDR}.

\section{Le positionnement}

\label{positionnement}
Le framework que nous souhaitons développer ne se focalisera pas sur l'une ou l'autre spécification. Tel que décrit dans la section \ref{frameworksAnalyse}, certains frameworks permettent d'aider l'application lors de son évolution, d'autres permettent de faire correspondre d'anciennes bases de données, ou encore aident au design du modèle. Dans notre cas, nous aimerions fournir un système simple permettant de faciliter l'architecture d'une application, en cachant intégralement le schéma de données au niveau de la couche de persistance (abstraction de la couche de persistance). \\L'utilisation de ce framework permettra aussi de faire évoluer le modèle d'information, sans perte de fonctionnalité.


\chapter{Background technique}

Lors de ce point, nous vous présenterons les différentes fonctionnalités qu'offrent les bases de données Neo4J et OrientDB. Nous entreprendrons également une comparaison entre ces deux BDOG afin de mettre en lumière ce qui nous semble être les points  forts et les points faibles de chacune.

\section{Neo4J}

\subsection{Description}

Créée par Neo Technologie, une société américaine et suédoise, elle est actuellement la base de données orientée graphe  la plus utilisée dans le monde\cite{DBEnginesSite}. Développée en Java sous licence GPL V3, AGPL ou licence commerciale, Neo4J représente les données sous forme de \enquote{Nœuds} et de \enquote{Relations}. Chacun de ces éléments peut contenir une ou plusieurs propriétés. Les propriétés sont des couples clé/valeur de type simple, comme des chaines de caractères ou des valeurs numériques, des coordonnées spatiales, etc\cite{Neo4JSite}.

L'une des particularités de Neo4J est l'absence de structure définie : un nœud peut être labellisé afin de permettre le travail sur un ensemble d'éléments mais il n'y aura aucune contrainte sur les propriétés du nœud. Cette particularité rend ce SGBD adapté pour les modèles évoluant fréquemment.


\subsection{Langage de requête}

Le langage propre à Neo4J se nomme \enquote{Cypher}\label{Cypher}, il a pour but de réaliser plus simplement que SQL les opérations de parcours ou d'analyses de proximité.

\begin{lstlisting}[language=java, frame=single]
CREATE (James:Person {name:"James"})
CREATE (John:Person {name:"John"})
CREATE (gilles:Person {name:"Gilles"})
CREATE (jane:Person {name:"Jane"})
CREATE (tim:Person {name:"Tim"})
CREATE (James)-[:PARENT_OF]->(gilles)
CREATE (John)-[:PARENT_OF]->(jane)
CREATE (jane)-[:PARENT_OF]->(tim)
CREATE (gilles)-[:PARENT_OF]->(tim)
\end{lstlisting}

Ces requêtes vont créer 5 nœuds et 4 relations \texttt{:PARENT\_OF}, nous pouvons aisément comprendre que \enquote{James} est parent de \enquote{Gilles}.

\begin{lstlisting}[language=java, frame=single]
MATCH (p:Person)-[:PARENT_OF]->(c:Person) 
RETURN DISTINCT (p)
	
\end{lstlisting}

La requête ci-dessus, va retourner tous les nœuds distincts qui ont une relation \texttt{:PARENT\_OF} avec un autre nœud.

\begin{lstlisting}[language=java, frame=single]
MATCH (gp:Person)-[:PARENT_OF*2]->(c:Person) 
RETURN DISTINCT (gp)
	
\end{lstlisting}

Celle-ci, quant à elle va retourner toutes les personnes qui sont \enquote{parents de parents} et donc grands-parents. 

Ces deux exemples peuvent montrer la force de l’utilisation d’un SGBD de type graphe pour représenter un ensemble hiérarchique de données par rapport aux SGBD relationnels qui nécessiteraient une double jointure sur la Table \enquote{Person}.

\subsection{Communication}

La BDOG Neo4J peut être utilisée sous plusieurs formes.

La première option est une solution embarquée, ce choix peut être très intéressant en alternative au très célèbre SQLite relationnel.

La deuxième, pour toute application distribuée, est une solution autonome pouvant tourner comme un service sur tout type de plateforme. Le protocole \enquote{Bolt}, développé par \enquote{Neo Technologie}, est grandement conseillé pour communiquer avec ces serveurs distants.

Son utilisation est simple grâce à l'emploi de la librairie native à Neo4J pour Java (neo4j-java-drive) ou avec le maniement de l’API Rest déployée en même temps que le SGBD.

\section{OrientDB}


\subsection{Description}

OrientDB est un SGBD initialement développé en C++ (Orient ODBMS), repris ensuite en 2010 en Java par Luca Garulli dans une version multi-modèle sous licence Apache 2.0, GPL et AGPL. Actuellement 3ème mondial\cite{DBEnginesSite}, il offre de nombreuses fonctionnalités intéressantes que nous allons décrire\cite{OrientDBSite}.

OrientDB associe Document et Graphe. Il combine la rapidité et la flexibilité du type document ainsi que les fonctionnalités de relations des bases de données graphe.
\newpage
Ce SGBD est composé de trois grands éléments :

\begin{itemize}
\item \textbf{Document \& Vertex} : sources de contenus, pouvant être considérées comme des containers de données. On peut les comparer avec les lignes d'une base de données relationnelle.
\item \textbf{Links \& Edge} : Une arête orientée reliant deux éléments non nécessairement distincts.
\item \textbf{Property} : Typée ou embarquée dans un document JSON, ceci va représenter le contenu de l'information. Ces propriétés sont bien entendu primordiales pour ordonner, rechercher, etc.
\end{itemize}

Chaque Document ou Vertex appartient à une \enquote{Class} qui peut être strictement définie ou plus laxiste. Comme dans la programmation orientée objet, OrientDB offre le principe de polymorphisme avec un système d'héritage entre les classes. 

OrientDB est fourni dans sa version community avec un système de clustering permettant à l'utilisateur de gérer correctement les montées en charge. Chaque document est identifié avec une partie désignant le cluster dans lequel l'information est stockée et une autre partie désignant sa position dans ce dernier (exemple @rid: 10:12). Chaque classe peut être associée à un ou plusieurs clusters, permettant d'optimiser les accès dans des ensembles plus petits.


\subsection{Langage de requête}

OrientDB utilise une sorte de SQL avancé pour interpréter les requêtes. On peut de plus utiliser le langage Gremlin.

Voici quelques exemples d'utilisation du SQL avancé dans OrientDB.

\begin{lstlisting}[language=SQL]
CREATE CLASS Person EXTENDS V
CREATE CLASS Company EXTENDS V
CREATE CLASS WorkAt EXTENDS E
CREATE PROPERTY Person.firstname string
CREATE PROPERTY Person.lastname string
CREATE PROPERTY Company.name string
INSERT INTO Person(firstname, lastname) VALUES ("Gilles","Bodart"),("Marie","Van Cutsem")
	ou
INSERT INTO Company set name = "ACME"

\end{lstlisting}

Cet ensemble de requêtes ressemblant au langage SQL permet de créer deux vertex, Person et Company, un Edge WorkAt et leur associe certaines propriétés. Les deux types d’insert différents permettent comme en SQL d’ajouter un nœud.

\begin{lstlisting}[language=SQL]
SELECT FROM V
\end{lstlisting}
\begin{table}
	\centering
	\begin{tabular}{|c|c|c|c|c|c|}
   		\hline
  		\multicolumn{3}{|c|}{Metadata} & \multicolumn{3}{c|}{Properties} \\
   		\hline
   		@rid & @version & @class & firstname & lastname & name \\
   		\hline
   		10:0 & 1 & Person & Gilles & Bodart &  \\
   		10:1 & 1 & Person & Marie & Van Cutsem &  \\
   		11:0 & 1 & Company &  &  & ACME \\
   		\hline
	\end{tabular}
	\caption{Résultat de la requête \enquote{SELECT FROM V} dans le BDOG OrientDB.}
\end{table}

Nous pouvons observer qu'OrientDB se charge de qualifier les documents de plusieurs métadata en leur octroyant par exemple un identifiant unique (\no cluster : position), un numéro de version pour permettre une gestion de transaction \enquote{full optimistic}\footnote{On laisse l'utilisateur continuer sa transaction et le refus se fera lors du \enquote{commit} s'il y a eu une modification concurrente du même document} et le \texttt{@class}, quant à lui représente la structure du document.

\begin{lstlisting}[language=SQL]
CREATE Edge WorkAt from 10:1 to 11:0
\end{lstlisting}

Cette petite requête va lier le document ayant l'id 10:1 au document dont l'id est 11:0 par une relation WorkAt. Nous pouvons traduire en français que Marie Van Cutsem travaille chez ACME \cite{OrientDBGettingStarted}.

\subsection{Communication}

OrientDB embarque une API Rest complète\cite{fielding2000architectural}. Toute action pouvant être faite sur les interfaces web et consoles peut être reproduite au travers de cette API.

Outre la communication via le protocole \texttt{http}, nous pouvons aussi accéder à la base de données via une des trois librairies Java développée par OrientDB.


\section{Comparaison} 
\footnotetext[2]{Langage fortement similaire à SQL avec certaines légères modifications}
Suite aux recherches effectuées dans la section \ref{NoSqlEvol}, nous avons tenté de dresser un tableau comparatif permettant de distinguer Neo4J et OrientDB sur base des critères nous paraissant les plus pertinents.
\begin{center}

\begin{longtable}[c]{|l|M{5cm}|M{5cm}|}
\hline
\backslashbox {Critère}{BDOG} & Neo4J & OrientDB  \tabularnewline
\hline
Format de données & JSON & JSON 
\tabularnewline \hline
Langage & Cypher & SQL\footnotemark \tabularnewline
\hline
Schéma de donnée strict & X & \checkmark  \tabularnewline
\hline
Principe d'héritage & X & \checkmark \tabularnewline
\hline
Clusturing & Configurable & Natif \tabularnewline
\hline
Communication & BOLT (protocole propriétaire) & REST (via HTTP) \tabularnewline
\hline
Environnement & Client/Server ou embarquée & Client/Server uniquement \tabularnewline
\hline
Évolutivité & L'absence de schéma strict entraîne une grande liberté dans la création et la modification des nœuds & Les classes doivent préalablement être configurées sur le serveur \tabularnewline \hline
Modèle de représentation & Uniquement graphe & Multimodèle\tabularnewline \hline
 Création de user & En cours de développement & \checkmark \tabularnewline \hline
 Sécurité & Par défaut : simple connexion donnant un accès total & Présence de groupes d'utilisateurs ainsi que d'un ensemble de droits singuliers\tabularnewline \hline 
  Interface web & \checkmark & \checkmark\tabularnewline \hline
Implémentation de fonctions & \checkmark & \checkmark\tabularnewline \hline
Rapidité\footnotemark & 7m 10s & 4m 31s \tabularnewline \hline
\caption{Tableau comparatif entre Neo4J et OrientDB.}
\end{longtable}
\end{center}
\footnotetext{Temps obtenu en effectuant 10 000 requêtes sur le même graphe de données avec la même requête au travers d'un appel Java depuis un ordinateur vers un serveur distant (même hébergement pour les deux BDOG).}

Au vu de ce tableau, nous nous apercevons qu’OrientDB, grâce à son système d'autorisation, semble ainsi correspondre à une approche plus standardisée d'une base de données. En utilisant le langage SQL comme langage de requête, OrientDB  conforte à nouveau les utilisateurs de bases de données relationnelles en leur permettant d'utiliser un langage connu. La rapidité d'exécution est elle aussi favorable à OrientDB. Cependant le fait de devoir configurer quelque peu le serveur pourrait limiter son intérêt lors de l'implémentation de petites applications. 

Neo4J a lui préféré jouer la carte de la spécificité :
\begin{itemize}
\item[•] Nouveau langage
\item[•] Nouveau protocole
\item[•] Accès simple à l'information
\end{itemize}
Grâce à ses fonctionnalités et ses structures de représentation de l'information totalement évolutives, Neo4J se fait une place à part entière dans l'univers des BDOG.

Avec Archipelago, l'utilisation de Neo4J ou d'OrientDB ne nécessitera aucun apprentissage supplémentaire ni aucun changement dans l'application.

\chapter{Solutions existantes}
\begin{center}
\enquote{\textit{Un peuple qui oublie son passé se condamne à le revivre.}}\footnote{Winston Churchill}
\end{center}

Dans le même état d'esprit, nous tenterons de vous décrire les solutions existantes dans le but que notre recherche puise le potentiel de ces librairies. Et ce, afin de construire un framework qui aspire à les utiliser à bon escient.  À l'inverse, certaines librairies ne seront pas exploitées car elles ne nous permettent pas d'atteindre nos objectifs de simplification et/ou d'abstraction (cf. \ref{positionnement}).

\section{Les librairies} 
\label{librairie}
Afin que nous parlions d'un même concept, nous allons définir le terme \enquote{librairie} comme suit : 

\enquote{\textit{Élément d'outil de développement Java constitué de procédures et d'objets prédéfinis, utilisables de façon modulaire, et qui permettent de bâtir des applications Java, sans avoir à programmer de code source Java.}}\footnote{\url{http://www.dicofr.com/cgi-bin/n.pl/dicofr/definition/20010101002918}}


\subsection{Librairie Neo4J}

Une librairie Java développée par Neo Technologie existe et permet de travailler aisément avec une base de données Neo4J embarquée ou à distance. Elle est en constante évolution et se trouve sur une plateforme open source. 

Exemple de communication avec la librairie Neo4J et le protocole \enquote{Bolt}:
\vspace{0.6cm}
\begin{lstlisting}[language=java]
Driver driver = GraphDatabase.driver("bolt://localhost:7687", AuthTokens.basic("matrix", "neo"));
Session session = driver.session();
session.run("CREATE (a:Person {firstName:{name},lastName:{lastName}})", parameters("firstName","Gilles","lastName","Bodart"));
session.close();
driver.close();

\end{lstlisting}

Bien que cette libraire permette d'accéder directement au langage Cypher depuis un code Java, elle ne peut malheureusement être utilisée avec une autre BDOG que Neo4J. 

\subsection{Librairie OrientDB}

La librairie OrientDB pour Java est composée de trois éléments:

\begin{itemize}
\item[•] \texttt{graph API}
\item[•] \texttt{document API}
\item[•] \texttt{object API}
\end{itemize}

La \texttt{graph API} d'OrientDB couvre 80\% des use cases classiques d'un utilisateur et supporte tous les modèles de représentations comme un unique multi-modèle de données. Elle travaille sur des \enquote{Vertex} et des \enquote{Edges}, respectivement nœuds et relations, et est compatible avec le standard TinkerPop (cf. \ref{TinkerPop}).

La \texttt{document API} permet de couvrir les 20\% restants, elle est plus simple d'utilisation mais offre une utilisation plus atomique. Par exemple, les relations ne peuvent être qu'unidirectionnelles tandis que la bidirectionnalité est offerte dans l'API précédente (\texttt{graph API}). Un \texttt{document} est un élément représentant l'information. Par défaut, aucune relation ne sera construite, nous devons dès lors gérer manuellement chaque lien entre documents.

La dernière librairie se focalise sur les objets Java, elle n'a plus été améliorée depuis la version 1.5 d'OrientDB\footnote{À l'heure de l'écriture de ce mémoire, nous sommes à la version 2.2 et la version 3 a bientôt terminé sa phase de \enquote{bêta test}}.
\newpage
\section{Les frameworks}

Ainsi que nous avons défini le terme \enquote{librairie} dans la section \ref{librairie} , nous allons préciser le terme \enquote{framework}, utilisé à de nombreuses reprises dans ce travail.

\enquote{\textit{Un framework désigne en programmation informatique un ensemble d'outils et de composants logiciels à la base d'un logiciel ou d'une application. C'est le framework, ou structure logicielle en français, qui établit les fondations d'un logiciel ou son squelette.}}\footnote{\url{http://www.journaldunet.com/solutions/pratique/dictionnaire-du-webmastering/outils/19466/framework-definition-traduction.html}}


\subsection{Hibernate}

Hibernate, soutenu et développé par JBoss, a mis au point un système de relations entre le code Java et le SGBD Neo4J, en réutilisant les mêmes annotations de relations que celles employées pour les bases de données relationnelles, à savoir :

\begin{itemize}
\item[•] \textbf{@OneToOne} : Relation 1-1
\item[•] \textbf{@ManyToOne} : Relation n-1
\item[•] \textbf{@OneToMany} : Relation 1-n
\item[•] \textbf{@ManyToMany} : Relation n-n
\end{itemize}

Bien qu'à l'heure actuelle, aucune intégration n'ait été implémentée pour communiquer avec OrientDB, un ticket est ouvert (OGM-855)\footnote{\url{https://hibernate.atlassian.net/browse/OGM-855}} depuis 2 ans auprès d'Hibernate.

En voyant la syntaxe utilisée dans ce framework, nous sommes dans l'obligation de spécifier le type de relation entre deux nœuds. Ceci freine l'évolution aisée de l'application dans le temps. Nous aimerions permettre au développeur de créer une relation, en utilisant une unique annotation que nous appellerions \textbf{\texttt{@bridge}} en référence aux ponts qui lient les îles d'un archipel. \label{bridge}

\subsection{Spring Data}

Spring Data, comme Hibernate, possède un module de communication avec le SGBD Neo4J. Il intègre au célèbre Framework Spring, les fonctionnalités de Neo4J-OGM\footnote{Object Graph Mapper} qui permettent de qualifier une classe avec certaines annotations facilitant la sérialisation et la désérialisation vers la représentation graphique.

Exemple : 

\begin{lstlisting}
// Spécification du nom du Label du nœud
@NodeEntity(label="Film")
public class Movie {
// Spécification de l'identifiant technique donné par Neo4J
   @GraphId Long id;
// Binding de la propriété "title" spécifiée dans l'annotation
   @Property(name="title")
   private String name;
}

// Pas de spécification du nom du Label, 
// il prendra par défaut le nom de la classe
@NodeEntity
public class Actor extends DomainObject {

	... 
	
// Spécification d'une relation partante de type "ACTED_IN"
   @Relationship(type="ACTED_IN", direction=Relationship.OUTGOING)
   private List<Role> filmography;
}
// définition du type de Relation "ACTED_IN" 
@RelationshipEntity(type="ACTED_IN")
public class Role {
    @GraphId   
    private Long relationshipId;
    @Property  
    private String title;
// Spécification du nœud de départ
    @StartNode 
    private Actor actor;
// Spécification du nœud d'arrivée
    @EndNode   
    private Movie movie;
}
\end{lstlisting}
Nous nous inspirerons grandement de ce framework pour le développement futur d'Archipelago, tout en y ajoutant la fonctionnalité d'interchangeabilité entre les différentes BDOG. 

\subsection{Apache TinkerPop}
\label{TinkerPop}
Apache TinkerPop est un Framework open source d’utilisation de graphe : il regroupe un grand ensemble de fonctionnalités et d’algorithmes. Son écosystème est de plus en plus agrémenté de librairies externes développées par des tierces personnes.

Il se considère lui-même comme étant d’utilisation complexe pour les nouveaux développeurs car il nécessite l’utilisation d’un environnement qui lui est propre, la \enquote{Gremlin-console}.

Les développeurs de ce framework ont mis au point un langage de travail sur les graphes appelé \enquote{Gremlin}. Le langage dont nous avons parlé en section \ref{Cypher} s’est grandement inspiré de ce dernier\cite{tinkerPopSite}.
\newpage
Exemple d'utilisation :

\begin{lstlisting}
gremlin> g.V() /* récupère tous les nœuds du graphe */
==>v[1]
==>v[2]
==>v[3]
==>v[4]
==>v[5]
==>v[6]
gremlin> g.V(1) /* récupère le nœud d'Id 1 du graphe*/
==>v[1]
gremlin> g.V(1).values('name') /* récupère le nœud d'Id 1 du graphe et renvoie sa propriété 'name' */
==>marko
gremlin> g.V(1).outE('knows') /* récupère les relations 'knows' partant du noeud d'Id 1 */
==>e[7][1-knows->2]
==>e[8][1-knows->4]
gremlin> g.V(1).outE('knows').inV().values('name') /* retourne le nom des personnes que le nœud 1 connait */
==>vadas
==>josh
gremlin> g.V(1).out('knows').values('name') /* même résultat */
==>vadas
==>josh
gremlin> g.V(1).out('knows').has('age', gt(30)).values('name') /* retourne le nom des personnes âgées de plus de 30 ans que le nœud 1 connait */
==>josh
\end{lstlisting}

Comme expliqué plus haut, le langage doit être exécuté dans une invite de commande ou dans un serveur Gremlin. Nous sommes dès lors contraints d’installer et de configurer ce dernier pour pointer vers l’un ou l’autre SGBD.

Nous souhaitons créer Archipelago pour permettre la réutilisation des modèles OO\footnote{\textbf{O}rienté \textbf{O}bjet (cf. glossaire)} existants, et permettre ainsi aux développeurs de découvrir les BDOG sans avoir besoin d'utiliser un autre langage et/ou environnement, comme TinkerPop l'exige.



\part{Contribution}
\chapter{Le framework}

Au sein de cette section, nous décrirons notre framework nommé \enquote{Archipelago}. Nous l'introduirons par un exemple illustratif d'utilisation des bases de données orientées graphes et nous retracerons l'ensemble des fonctionnalités que permet ce framework.

\section{Exemple illustratif}

Pour la suite de ce mémoire, il est primordial d'avoir un exemple concret de modèle habituellement persisté avec un modèle relationnel mais qui pourrait néanmoins être transposable dans une BDOG.

\subsection*{L'école}

Imaginons la représentation d'une école composée d'élèves, de professeurs, de classes, de salles techniques, de travailleurs, ... dont le diagramme de classes se trouve en Annexe (\ref{fig:SchoolDiagram}).

Les liens entre les différents objets peuvent être très nombreux. Nous pouvons imaginer que les étudiants sont amis, membres de famille, ennemis, amoureux, ... il en est de même pour les professeurs : ils peuvent avoir les mêmes relations que les étudiants, mais en outre ils vont être assignés à des cours, à des classes, ... toutes ces liaisons peuvent être fortement compliquées à représenter sur une base de données relationnelle. L'utilisation d'une BDOG dans ce cas, semble tout à fait adéquate. Durant la suite de ce mémoire, nous utiliserons donc ce modèle.



\section{Piste de normalisation} 
Comme nous l'avons présenté dans le point \ref{NoSqlEvol}, nous pouvons constater de par l'implémentation du théorème de CAP, que chaque SGBD NoSQL se concentre sur l'une ou l'autre fonctionnalité. 

Dans cette partie, nous allons tenter d'abstraire un ensemble d'éléments afin de permettre aux futurs utilisateurs de pouvoir communiquer avec des BDOG sans pour autant devoir connaitre leurs spécifications. 

Notre démarche dans la proposition de cette fonctionnalité d'abstraction, est une démarche favorisant la découverte de nouvelles implémentations de BDOG afin de satisfaire au mieux les attentes des entreprises. En plus de l'abstraction des librairies spécifiques aux BDOG, Archipelago devra contenir les fonctionnalités suivantes :
 
\begin{enumerate}
\item Utilisation d'une librairie unique pour toutes BDOG.
\item Contrôle sur les propriétés et les relations.
\item Opération de base de persistance CRUD.
\item Système de transaction.
\end{enumerate}

La suite de ce mémoire portant sur le développement de ce framework Java, vous montrera comment utiliser Archipelago.
\section{Utilisation}
\label{utilisation}
Les figures \ref{fig:HelocoP} et \ref{fig:HelocoG} offrent une approche schématisée de l'utilisation d'Archipelago. 
\\La première vous décrit le fonctionnement de l'étape de persistance, tandis que la deuxième vous expose la manière dont nous allons récupérer l'information. Plus tard, dans les sections \ref{persistance} et \ref{récupération}, vous pourrez apercevoir des schémas plus détaillés de ces fonctionnalités.
\vspace*{\stretch{1}}
\begin{figure}[!ht]
\centering
\includegraphics[scale=0.7]{figures/HelocoP.png}
\caption{Un développeur appose les annotations bridge sur les classes et persiste les objets Java avec Archipelago dans la BDOG.}
\label{fig:HelocoP}
\end{figure}
\vspace*{\stretch{1}}
\begin{figure}[!ht]
\centering
\includegraphics[scale=0.8]{figures/HelocoG.png}
\caption{Un développeur récupère des objets depuis une BDOG en utilisant Archipelago.}
\label{fig:HelocoG}
\end{figure}
\vspace*{\stretch{1}}
\newpage
\label{opérations}
\subsection{La configuration}
\label{configuration}
Archipelago permet de se lier à Neo4J ou à OrientDB sans changer le code source de l'application. 
Cependant, une légère configuration est nécessaire pour initialiser les paramètres d'exécution.

Le fichier de configuration doit se nommer \enquote{\texttt{config.archipelago.json}} et être présent dans les ressources du projet. Par facilité de développement et de testing, nous avons décidé arbitrairement de figer le nom ainsi que l'emplacement de ce fichier dans la première version de ce framework. Il est cependant aisé de modifier cette obligation en la rendant paramétrable dans une potentielle deuxième version.

Voici le canevas de ce fichier :

\begin{lstlisting}[language=JavaScript]
{
  "database": {
    "type": "",        // Choix entre NEO4J et ORIENT_DB
    "username": "",
    "password": "",
    "url": "",         // URL de la base de données
    "name": "",        // Nom de la base de données
    "port": 1234       // Port de communication
  },
  "deepness": 3,       // Profondeur de persistance voir ci-après
  "domainRootPackage": "org.archipelago.test.domain.school" 
                   // Package où se trouvent les classes du domaine 
}
\end{lstlisting}

La seule autre modification à apporter, est l'apposition de l'annotation \texttt{@Bridge}, comme expliqué dans la section \ref{bridge}. Cette annotation sera utilisée par Archipelago afin de spécifier les relations que nous souhaitons créer entre les différents objets.

\subsection{La persistance}
\label{persistance}

La persistance est l'élément principal de ce framework. Afin de ne pas être tenus par une syntaxe appartenant à une BDOG propre, nous nous sommes basés sur une approche de représentation OO. 

La persistance de ces objets ainsi que des éléments qui leur sont liés dépend en partie du fichier de configuration qui vient d'être décrit dans la section précédente (\ref{configuration}). 

Afin d'assurer la persistance des éléments liés, nous avons opté pour une approche récursive en \enquote{depth-first} avec marquage de sommet. Lors du parcours du graphe de données, représenté par les différentes références entre les objets Java, nous enregistrons l'identifiant venant d'être généré par la BDOG dans une \texttt{Map<Object,Object>}\footnote{Représentation d'un ensemble de clé/valeur dont la clé est l'objet que nous venons de persister et la valeur est  l'identifiant.}. En effet, pour créer un lien entre deux éléments, il faut absolument que ceux-ci soient présents dans la base de données. Garder la trace des identifiants nous permet aussi d'accélérer la phase de liaison entre les nœuds, car cela nous évite un appel supplémentaire à la BDOG.

La propriété \enquote{deepness} est primordiale pour la performance de cet outil, elle permet de définir la profondeur de persistance d'un objet. Ce procédé empêche de tomber dans des boucles infinies, problème courant lorsque nous travaillons avec des modèles ayant des relations bidirectionnelles comme suit : 

\begin{lstlisting}
Archipelago arch = Archipelago.getInstance();
// Création d'un objet Student
Student gilles = new Student();
// Création d'un autre objet Student
Student thomas = new Student();

// Lien entre Student et un autre Student
gilles.setFriend(thomas);
// Lien entre Student et un autre Student
thomas.setFriend(gilles);

arch.persist(gilles);

// Boucle infinie : gilles -ami-> thomas -ami-> gilles -ami-> thomas -> ...
// Comme "deepness" vaut 3 : gilles -ami-> thomas -ami-> gilles --> STOP
\end{lstlisting}

En effet, comme nous utilisons la récursivité au travers de l'introspection des classes, nous pouvons tomber sur une classe faisant référence à elle-même\footnote{voir exemple ci-dessus}, ce qui entraine la dite boucle infinie. Ainsi avec la valeur sentinelle contenue dans la propriété \enquote{deepness}, nous rompons la boucle de persistance générée lors du parcours des références après avoir atteint la profondeur souhaitée. Archipelago continue à l'aide du back-tracking la suite de la persistance si nécessaire.

\vspace*{\stretch{1}}
\begin{figure}[!h]
\centering
\includegraphics[scale=0.6]{figures/Persist.png}
\caption{Flux de persistance d'un objet au travers du framework Archipelago.}
\label{fig:Persist}
\end{figure}
    
\vspace*{\stretch{1}}
\newpage
Pour ce qui est de la persistance des liens potentiels entre deux objets, nous avons fait le choix de créer des relations unidirectionnelles. Afin de les créer, il faut apposer l'annotation \texttt{@Bridge} dans les classes possédant des liens vers d'autres classes; ces annotations spécifieront les origines des futures relations.

Il est nécessaire de décrire le nom de la future relation dans l'annotation par le biais de l'attribut \texttt{descriptor}. Lors du développement du framework, nous avons éprouvé quelques difficultés à récupérer ces relations depuis la base de données, dès lors, nous imposons que la valeur de cet attribut soit unique au sein même d'une classe. 

Nous avons cependant ajouté la possibilité d'obtenir automatiquement une relation réciproque lors de la persistance, en associant la valeur \texttt{true} à l'attribut \texttt{biDirectionnal} de l'annotation. 

Exemple avec la Classe \textit{Student.java}

\begin{lstlisting}
public class Student extends Person {

    // Spécification d'un lien entre Student et Lesson, 
    // le nom de cette relation sera Follow
    @Bridge(descriptor = "Follow")
    private List<Lesson> lessons = new ArrayList<>();

    // Spécification d'un lien entre Student et Student, 
    // le nom de cette relation sera FriendOf
    @Bridge(descriptor = "FriendOf")
    private List<Student> friends = new ArrayList<>();
    
    // Spécification d'un lien entre Student et une sous classe de Person, 
    // le nom de cette relation sera FamilyMember et sera bidirectionnelle
    @Bridge(descriptor = "FamilyMember", biDirectionnal = true)
    private List<? extends Person> familyMember = new ArrayList<>();
    
    // Spécification d'un lien entre Student et Promotion, 
    // le nom de cette relation sera GraduatedIn
    @Bridge(descriptor = "GraduatedIn")
    private Promotion prom;
    
    ...
    
\end{lstlisting}

L'intérêt de cette utilisation est qu'au moindre changement de modèle tel qu'un ajout de propriété, l'ensemble de la couche de persistance sera adapté à ce changement sans devoir exécuter le moindre script (à l'exception de la création d'une nouvelle classe pour OrientDB).

Si nous prenons l'exemple de l'école (cf. méthode en annexe) nous pouvons réaliser qu'en un seul graphe, nous visualisons l'ensemble des relations, qu'elles soient unidirectionnelles ou bidirectionnelles.
\newpage

\begin{lstlisting}
Archipelago arch = Archipelago.getInstance();

// Génération d'un objet School avec l'ensemble de ses liens
School school = genSchool()

arch.persist(gilles);
\end{lstlisting}

\vspace*{\stretch{1}}
\begin{figure}[!ht]
\centering
\includegraphics[scale=0.9]{figures/ecoleNeo4J.png}
\caption{Graphe généré dans Neo4J après appel de la méthode persist du framework Archipelago sur un objet School.}
\label{fig:ecoleNeo4J}
\end{figure}

\vspace*{\stretch{1}}
\newpage
\subsection{La liaison}

Tout graphe se doit de pouvoir lier deux nœuds entre eux, Archipelago offre donc la possibilité de spécifier une liaison entre deux objets en en utilisant un troisième, dont voici un exemple : 

\begin{lstlisting}

Archipelago arch = Archipelago.getInstance();
// Création d'un objet City
City winterfell = new City("Winterfell");
// Création d'un autre objet City
City kingsLanding = new City("King's Landing");

// Création d'un objet Road
Road road= new Road();
// spécification de la propriété distance à 500 (de type long)
road.setDistance(500l);
// spécification de la propriété unité à "leagues"
road.setUnit("leagues");
        
// création d'un lien entre l'objet winterfell et l'objet kingsLanding
// le lien aura les propriétés contenues dans l'objet road
// winterfell -road-> kingsLanding
arch.link(winterfell, kingsLanding, road);

\end{lstlisting}

Comme nous l'avons décrit dans l'exemple précédent, nous allons lier ces deux villes par une relation \enquote{Road} contenant les propriétés \enquote{distance} et \enquote{unité}.

\begin{figure}[!ht]
\centering
\includegraphics[scale=1.2]{figures/Rel.png}
\label{fig:Relation}
\caption{Résultat obtenu après utilisation de la méthode link d'Archipelago (avec Neo4J).}
\end{figure}

Il est toutefois possible, si nous le spécifions à l'aide de la valeur \texttt{true} dans le quatrième attribut de la méthode, de générer automatiquement la relation réciproque et ainsi créer une relation bidirectionnelle. 

\begin{lstlisting}
// winterfell -road-> kingsLanding et kingsLanding -road-> winterfell
arch.link(winterfell, kingsLanding, road, true);
\end{lstlisting}


\begin{figure}[!ht]
\centering
\includegraphics[scale=1.2]{figures/RelBidir.png}
\caption{Résultat obtenu après utilisation de la méthode link bidirectionnelle d'Archipelago (avec Neo4J).}
\label{fig:RelationBiDir}
\end{figure}
\newpage
\subsection{La récupération}
\label{récupération}
La récupération de l'information est la raison pour laquelle nous la stockons. A quoi bon enregistrer une valeur dans une base de données si nous ne souhaitons jamais l'utiliser ultérieurement ?

Pour cela, Archipelago offre un système de création de requête. Grâce à ce procédé, que la BDOG soit OrientDB ou Neo4J, nous serons en mesure de récupérer notre objet sans changer notre code source. Dans le fichier de configuration spécifié dans la section \ref{configuration}, une propriété nommée \texttt{domainRootPackage} est présente. Celle-ci est utilisée par notre utilitaire de réflexion afin de connaitre l'ensemble des classes potentiellement récupérables depuis la BDOG. Il sera dès lors impossible de récupérer un objet si la classe qui le décrit, ne fait pas partie du package ou d'un sous-package exposé par la valeur contenue dans cette propriété.

Voici un exemple:

\begin{lstlisting}
Archipelago arch = Archipelago.getInstance();

// Initialisation de la requête
ArchipelagoQuery aq = a.getQueryBuilder()
// Spécification du type de nœud
                .of(Student.class)
// Génération de la requête
                .build();
List<Object> nodes = arch.execute(aq);
\end{lstlisting}

La requête, générée par l'exemple précédent va rechercher l'ensemble des étudiants de la base de données ainsi que les objets qui leur sont liés.

Un système de conditions est également mis en place ; il permet d'affiner les résultats obtenus: 

\begin{lstlisting}
Archipelago arch = Archipelago.getInstance();

// Initialisation de la requête
ArchipelagoQuery aq = a.getQueryBuilder()
// Spécification du type de nœud
                .of(Student.class)
// Initialisation de la condition
                .where(
// Élément de condition "firstName" = "Gilles"
                	of("firstName","Gilles"), ConditionQualifier.Equal)
// Génération de la requête
                .build();
List<Object> nodes = arch.execute(aq);
\end{lstlisting}

Cette requête va quant à elle rechercher les étudiants ayant \enquote{Gilles} comme prénom.
\newpage
Nous pouvons aussi ajouter des opérateurs logiques \enquote{OU} et \enquote{ET} comme suit :
\begin{lstlisting}
Archipelago arch = Archipelago.getInstance();

// Initialisation de la requête
ArchipelagoQuery aq = a.getQueryBuilder()
// Spécification du type de nœud
                .of(Student.class)
// Initialisation de la condition
                .where(
// Élément de condition "lastName" = "Bodart"
                	of("lastName", "Bodart"), ConditionQualifier.EQUAL)
// Ajout d'un lien logique ET avec l'élément "firstName" = "Gilles"
                .and(of("firstName", "Gilles"), ConditionQualifier.EQUAL)
// Ajout d'un lien logique OU avec l'élément "firstName" = "Thomas"
                .or(of("firstName", "Thomas"), ConditionQualifier.EQUAL)
// Génération de la requête
                .build();
List<Object> nodes = arch.execute(aq);
\end{lstlisting}
Dans notre troisième exemple, le système fournira donc la liste des étudiants ayant \enquote{Bodart} comme nom de famille et \enquote{Gilles} ou \enquote{Thomas} comme prénom. 

Le procédé mis en place à l'heure actuelle ne permet pas de créer des conditions complexes car il va ajouter chaque élément de condition à la suite de la requête courante. 

Pour l'exemple précédent, nous aurons donc généré la condition : 

\begin{lstlisting}[language=SQL]
(lastName = "Bodart" AND ( firstName = "Gilles" OR firstName = "Thomas"))
\end{lstlisting}

Comme expliqué plus haut, nous sommes actuellement dans l'incapacité de générer des requêtes possédant des sous-conditions comme suit :

\begin{lstlisting}[language=SQL]
(lastName = "Bodart" AND  firstName = "Gilles") 
 OR 
(lastName = "Blondiau" AND firstName = "Thomas")
\end{lstlisting}
\label{badCondition}
\`A L'heure actuelle, il n'est pas possible d'effectuer des requêtes sur les relations entre les objets. Cette piste sera primordiale pour une deuxième version de ce framework.
\newpage
Comme sus-cité dans la section \ref{utilisation}, voici un schéma récapitulatif de l'utilisation de la méthode de récupération d'Archipelago.
\vspace*{\stretch{1}}
\begin{figure}[!ht]
\centering
\includegraphics[scale=0.6]{figures/query.png}
\caption{Flux de traitement d'une requête de recherche dans Archipelago.}
\label{fig:Query}
\end{figure}

\vspace*{\stretch{1}}

\newpage


\section{Schéma conceptuel}

La démarche suivie dans le cadre de ce travail est la suivante :

\begin{center}
\textbf{Abstraire la relation entre le code et la base de données, et accéder plus simplement à l’utilisation des BDOG. }
\end{center} 

Nous avons tenté de nous représenter le graphe dans l'univers de la programmation et nous nous sommes aperçus qu'il existait une grande divergence et une grande complexité entre les implémentations spécifiques des BDOG.

Nous nous sommes dès lors questionnés sur la façon de s'éloigner de ces implémentations afin de ne plus être dépendants d'une représentation spécifique et de simplifier toute la procédure. Nous avons dès lors créé un ensemble d'éléments abstraits fournissant une interface entre les différentes librairies préexistantes.

Archipelago est donc un framework qui permet d'utiliser ces librairies spécifiques des BDOG en reprenant sur base d’une configuration, les éléments nécessaires et en simplifiant considérablement toutes les procédures de recherche et de création de requête.
\subsection{La structure d'Archipelago}

L'objectif principal du framework Archipelago est d'être une boite à outils comprenant les trois opérations décrites\footnote{voir \ref{opérations}} :
\begin{itemize}
\item[•] La persistance
\item[•] La liaison
\item[•] La recherche
\end{itemize}

Grâce au fichier \texttt{config.archipelago.json}, l'environnement va se moduler automatiquement de manière à pouvoir exécuter le code spécifique adéquat.

Pour ces opérations, nous allons avoir besoin d'utilitaires nous permettant de générer des requêtes de persistance, de liaison et de recherche, pour chaque BDOG. Ces différentes implémentations doivent respecter les obligations décrites par les classes \texttt{ArchipelagoScriptBuilder} ainsi que \texttt{ArchipelagoQueryBuilder}.

Nous pensons que l'on pourrait fusionner ces deux classes. Néanmoins, nous avons opté pour le choix de les scinder afin de garder une différenciation entre les requêtes qui créent de l'information et celles qui en récupèrent.

\newpage
\vspace*{\stretch{1}}
\subsubsection{ScriptBuilders}


\begin{figure}[!ht]
\centering
\includegraphics[scale=1.5]{figures/scriptBuilders.png}
\caption{Diagramme de classe représentant l'héritage des générateurs de script de persistance composant Archipelago.}
\label{fig:ScriptQuery}
\end{figure}

Chaque classe doit correspondre à une base de données et implémenter trois méthodes\footnote{Plus un petit nombre d'overload à implémenter.} \footnote{Chacune de ces requêtes doit être écrite dans le langage ciblé par la classe.} :
\begin{table}[ht!]
\centering
\begin{tabular}[c]{|l|M{12cm}|}
\hline
\textbf{Nom de méthode} & \textbf{Description}  \tabularnewline
\hline
\texttt{makeCreate} &  Cette méthode doit générer une requête permettant de créer un nœud. \tabularnewline
\hline
\texttt{makeMatch} & Cette méthode doit générer une requête permettant de récupérer l'identifiant correspondant à un objet. \tabularnewline
\hline
\texttt{makeRelation} &  Cette méthode doit générer une requête permettant de lier deux nœuds.  \tabularnewline
\hline

\end{tabular}
\caption{Relevé des méthodes à implémenter pour hériter de \texttt{ArchipelagoScriptBuilder}.}
\label{tab:ArchipelagoScriptBuilder}
\end{table}
\vspace*{\stretch{1}}
\newpage
\vspace*{\stretch{1}}
\subsubsection{QueryBuilders}

\begin{figure}[!ht]
\centering
\includegraphics[scale=1.5]{figures/queryBuilders.png}
\label{fig:QueryBuilders}
\caption{Diagramme de classe représentant l'héritage des générateurs de script de recherche composant Archipelago.}
\end{figure}

Comme précédemment, chaque classe doit correspondre à une base de données car la liste des méthodes à implémenter est légèrement plus importante.

En voici le détail :
\begin{table}[ht!]
\centering
\begin{tabular}[c]{|l|M{12cm}|}

\hline
\textbf{Nom de méthode} & \textbf{Description}  \tabularnewline
\hline
\texttt{init} & Initialisation de la requête de recherche.  \tabularnewline
\hline
\texttt{of} & Spécification de l'objet de la recherche.  \tabularnewline
\hline
\texttt{where} & Initialisation de conditions permettant de filtrer le résultat final.  \tabularnewline
\hline
\texttt{and} & Ajout d'une sous-condition liée avec un \texttt{ET} logique. \tabularnewline
\hline
\texttt{or} & Ajout d'une sous-condition liée avec un \texttt{OU} logique.   \tabularnewline
\hline
\texttt{build} & Finalise la requête de recherche de nœuds et génère une \texttt{ArchipelagoQuery}.   \tabularnewline \hline

\end{tabular}
\caption{Relevé des méthodes à implémenter pour hériter de \texttt{ArchipelagoQueryBuilder}.}
\label{tab:ArchipelagoQueryBuilder}
\end{table}
\vspace*{\stretch{1}}


\chapter{Evaluation}

Ce mémoire a été réalisé dans le but de développer un framework permettant d'abstraire les librairies spécifiques aux bases de données orientées graphe. Cependant, l'état actuel d'avancement de cet outil ne peut que le qualifier de \enquote{POC}\footnote{Proof of concept - Terme donné à un projet dont le but est de démontrer la faisabilité d'une approche d'architecture, d'une technologie ou d'une solution }.


\section{Points forts}

\subsection{La facilité}

Grâce à Archipelago et sa méthode de persistance d'un objet Java, il est aisé d'enregistrer des informations pouvant être fortement interconnectées dans des bases de données orientées graphe. 
Le marquage des sommets lors de cette opération nous permet aussi d'améliorer les performances du procédé. 

\subsection{La configurabilité}

Nous avons choisi de prendre un fichier JSON comme fichier de configuration car ce format est simple d'utilisation. À noter que l'utilisation d'un fichier YAML aurait pu fonctionner également. Néanmoins, au vu des faibles différences de représentations, nous ne voyons pas l'intérêt d'employer l'un plutôt que l'autre. C'est pourquoi nous avons opté pour le format JSON que nous affectionnons davantage. 

\`A l'heure actuelle, nous disposons d'un certain nombre de paramètres nous permettant d'orienter le framework vers l'une ou l'autre base de données et d'aider la récupération depuis ces dernières. De surcroît, le modèle mis en place permet aisément d'ajouter ou d'ôter de nouveaux paramètres en fonction des améliorations futures. 
\newpage
\subsection{L'abstraction}

L'utilisateur ne doit se soucier d'aucune mise en œuvre spécifique à la base de données ciblée. 

Archipelago, grâce à ses implémentations concrètes cachées derrière les classes abstraites \\\texttt{ArchipelagoScriptBuilder} ainsi que \texttt{ArchipelagoQueryBuilder}, permet à l'exploiteur de se concentrer sur la partie algorithmique de son application.

\subsection{La simplification}

La manière dont nous avons imaginé ce framework permet de réutiliser n'importe quel code existant. Il suffit alors à l'utilisateur d'ajouter les annotations \texttt{@Bridge} pour que son code soit compatible avec l'application de ce framework. 

Il pourra ainsi profiter de bases de données NoSql orientées graphe, au lieu de s'en tenir aux bases de données relationnelles\footnote{voir \ref{noSqlVSRel}}; les frameworks de communication avec ces dernières étant plus courantes et mieux connues dans l'univers de la programmation.

\subsection{La modularité}

Chaque utilisation de librairie spécifique de communication vers une base de données extérieure se trouve dans une classe séparée.

Ce genre d'architecture offre une maintenance aisée car elle permet de concentrer la recherche de problèmes dans un espace défini et bien cadré. De plus, si deux équipes sont affectées simultanément à ce framework, elles peuvent y ajouter de nouvelles BDOG sans se gêner, telles que par exemple ArangoDB\cite{arangoSite} ou encore JanusGraph\cite{janusGraphSite}. 


\section{Points à améliorer}
\subsection{Les performances}

Bien que nous ayons essayé d'améliorer ce point grâce au marquage des sommets, nous n'avons pas eu le temps d'approfondir ce procédé avec un marquage des arêtes. Dans notre exemple de l'école, la partie reprenant les étudiants est fortement interconnectée. En conséquence nous devons passer à de nombreuses reprises sur les mêmes arêtes du graphe pour vérifier si cette relation existe dans la base de données au lieu de retenir l'information et d'éviter la démarche. Ces nombreux passages ralentissent le processus\footnote{Et plus particulièrement en ce qui concerne OrientDB}.

\subsection{Les conditions}

Notre framework possède trois faiblesses principales en ce qui concerne la manière avec laquelle nous pouvons récupérer de l'information.

\subsubsection*{\bf Sous-conditions}

Comme nous l'avons évoqué dans le point \ref{badCondition}, nous pouvons actuellement générer des conditions simples.
Pour créer des conditions plus complexes, il faudrait effectuer une refonte du système d'imbrication afin de permettre à l'utilisateur de créer des sous-conditions. 

Exemple de condition impossible à générer actuellement :
\begin{lstlisting}[language=SQL]
(lastName = "Bodart" AND  firstName = "Gilles") 
 OR 
(lastName = "Blondiau" AND firstName = "Thomas")
\end{lstlisting}


\subsubsection*{\bf Conditions sur les relations}
De plus, il n'est  pas possible de faire une condition sur une relation entre deux nœuds. 

Par exemple nous pourrions avoir grâce à la requête Cypher suivante : 

\begin{figure}[!ht]
\centering
\includegraphics[scale=0.8]{figures/citiesRel.png}
\caption{Graphe Neo4J composé de 3 noeuds et de 4 relations.}
\label{fig:citiesRel}
\end{figure}
 
\begin{lstlisting}[language=SQL]
MATCH (d:City)-[rel:Road]->(a:City)
WHERE
	    rel.distance > 300
	AND rel.unit = "leagues"
RETURN (a)
// Quelles sont les villes éloignées de plus de 300 lieues ?
\end{lstlisting} 


\begin{figure}[!ht]
\centering
\includegraphics[scale=0.8]{figures/citiesRelFilt.png}
\label{fig:citiesRelFilt}
\caption{Graphe Neo4J composé de 2 nœuds et de 2 relations après exécution du filtre généré par Archipelago.}
\end{figure}

Les requêtes générées par Archipelago nous permettent donc de récupérer l'ensemble des villes liées par une route, mais nous ne pourrons pas nous limiter à celles situées à plus de 300 lieues.
\newpage
\subsubsection*{\bf Conditions sur les éléments liés}

Actuellement, l'ensemble des conditions s'applique sur le nœud principal de la requête.

\`A cause de cela, il nous est impossible de filtrer les éléments qui vont être liés avec celui-ci. 

Voici un exemple en Cypher:

\begin{figure}[!ht]
\centering
\includegraphics[scale=1]{figures/friendOf.png}
\label{fig:friendOf}
\caption{Graphe représentant les amis de \enquote{Gilles}.}
\end{figure}
 
\begin{lstlisting}[language=SQL]
MATCH (me:Student)-[:FriendOf]->(f:Student)
WHERE
	    me.firstName = "Gilles"
	AND me.lastName = "Bodart"
	AND	f.firstName = "Thomas" 
RETURN (me)-[]-(f)
/* Retourne les étudiants qui se nomment "Gilles Bodart" et lie ses amis qui se prénomment "Thomas" ? */
\end{lstlisting} 

\begin{figure}[!ht]
\centering
\includegraphics[scale=1]{figures/friendOfFilt.png}
\caption{Graphe représentant les amis de \enquote{Gilles} après exécution du filtre généré par Archipelago.}
\label{fig:friendOfFilt}
\end{figure}

Archipelago, à nouveau, ne permet pas de filtrer les amis liés au nœud principal. En raison de ce manque de possibilité, nous sommes exposés à des problèmes de charge dès lors que le nœud principal est lié à plusieurs millions d'autres.

\subsection{La récupération d'informations}

Dans l'état actuel d'avancement de ce framework, nous sommes en mesure d'enregistrer des informations sur les relations entre deux nœuds. Cependant il n'y a pas encore de procédé permettant de récupérer ces dernières dans un objet Java. Les  liaisons internes dans un objet seront récupérées mais nous ne bénéficierons pas de toutes les informations fournies lors de la persistance.

\begin{lstlisting}
public class City {

    private String name;

    @Bridge(descriptor = "Road")
    private List<City> connected = new ArrayList<>();
	...
\end{lstlisting}

\begin{lstlisting}
Archipelago arch = Archipelago.getInstance();
City winterfell = new City("Winterfell");
City kingsLanding = new City("King's Landing");
City dragonStone = new City("Dragonstone");
Road road= new Road();
road.setDistance(500l);
road.setUnit("leagues");
Road road2= new Road();
road2.setDistance(200l);
road2.setUnit("leagues");
a.persist(winterfell);
a.persist(kingsLanding);
a.persist(dragonStone);
a.link(kingsLanding,winterfell,road, true);
a.link(kingsLanding,dragonStone,road2, true);

ArchipelagoQuery aq = a.getQueryBuilder()
                .of(City.class)
                .where(of("name","King's Landing"), ConditionQualifier.EQUAL)
                .build();
List<Object> nodes = arch.execute(aq);
\end{lstlisting}
\newpage
Nous récupèrerons le nœud correspondant à la ville \enquote{King's Landing} et nous aurons dans la propriété \texttt{connected} deux autres villes, à savoir \enquote{Dragonstone} et \enquote{Winterfell}. Cependant, nous perdons dans l'application, les informations de distance et d'unité présentes dans les relations \texttt{Road}.


\subsection{La propreté et fiabilité du code}

Cette implémentation du framework pourrait être améliorée si l'on disposait de temps supplémentaire pour en évacuer les morceaux de code inutiles. En outre, il serait primordial d'y insérer des tests unitaires afin de s'assurer du bon fonctionnement de chacune des méthodes implémentées.
\label{propreteDuCode}
Le code est actuellement disponible sur un \enquote{repository github}\footnote{https://github.com/GillesBodart/Archipelago}, de façon à pouvoir récupérer\footnote{Nous n'en avons pas encore reçu.} un ensemble de commentaires constructifs par la communauté Java. 

\section{Questionnaire}

Comme objectif d'évaluation externe, nous avons rédigé un questionnaire afin de soumettre un aperçu de ce framework à des utilisateurs potentiels. Nous l'avons diffusé par le biais d'envois d'e-mail et de partage sur Facebook.

Nous avons principalement ciblé des collègues de cours, des collègues de travail ainsi que des connaissances susceptibles d'être intéressées par les BDOG.

Nous avons recueilli 51 réponses. Cependant nous devons soustraire de celles-ci, un certain nombre d'entre elles qui ne présentait aucun intérêt exploitable (réponses fantaisistes notamment). Notre ambition n'était pas de réaliser un questionnaire exhaustif mais bien de prendre l'avis d'utilisateurs éventuels. Il a été diffusé pendant 7 jours environ.


\subsection{Contenu quantitatif}

Les quatre premières questions concernent l'ensemble des répondants. Nous avons décidé de ne pas filtrer les questions ayant trait à leur identification afin qu'elles témoignent de l'intérêt porté au travail (51 réponses).

Les suivantes concerneront uniquement 32/51 réponses. 19 ayant été considérées comme sans objet. Un second filtrage sera appliqué durant l'analyse du questionnaire. Il est expliqué en légende de la figure \ref{fig:QIntFilt}.
\newpage
\vspace*{\stretch{1}}

\begin{figure}[!ht]
\centering
\includegraphics[scale=1]{figures/QHF.png}
\caption{Question 1) répartition homme/femme ayant répondu au questionnaire.}
\label{fig:QHF}
\end{figure}

\begin{figure}[!ht]
\centering
\includegraphics[scale=1]{figures/QAge.png}
\caption{Question 2) Tranche d'âge des répondants.}
\label{fig:QAge}
\end{figure}

\vspace*{\stretch{1}}
\newpage
\vspace*{\stretch{1}}

\begin{figure}[!ht]
\centering
\includegraphics[scale=1]{figures/QStatus.png}
\caption{Question 3) Situation scolaire et/ou professionnelle des répondants.}
\label{fig:QStatus}
\end{figure}

\begin{figure}[!ht]
\centering
\includegraphics[scale=.8]{figures/QProf.png}
\caption{Question 4) Domaines d'activité des répondants.}
\label{fig:QProf}
\end{figure}

\vspace*{\stretch{1}}
\newpage
\vspace*{\stretch{1}}

\begin{figure}[!ht]
\centering
\includegraphics[scale=1]{figures/QExistFilt.png}
\caption{Question 5) [Données filtrées] Répartition des répondants connaissant les BDOG.}
\label{fig:QExistFilt}
\end{figure}

\begin{figure}[!ht]
\centering
\includegraphics[scale=0.8]{figures/QIntFilt.png}
\caption{Question 6.a) [Données filtrées] Parmi les répondants ne connaissant pas les BDOG (+2 personnes ayant  répondu indûment à cette question), nous remarquons que près de la moitié d'entre eux (7/16) ne comptent pas s'intéresser aux bases de données graphe ou n'en voient pas l'utilité actuellement. Dans la suite de l'analyse de ce questionnaire, nous filtrerons davantage encore ceux pour qui les BDOG ne présentent aucun intérêt. C'est la raison pour laquelle notre échantillon ne comptera plus que 25 réponses.}
\label{fig:QIntFilt}
\end{figure}

\vspace*{\stretch{1}}
\newpage
\vspace*{\stretch{1}}

\begin{figure}[!ht]
\centering
\includegraphics[scale=0.8]{figures/QNbFilt.png}
\caption{Question 6.b) [Données filtrées] Nous avions 18 réponses \enquote{Oui} à la question 5, mais suite au deuxième filtre, l'échantillon ne comporte plus que 17 réponses (voir remarque ci-avant). Parmi les répondants connaissant les BDOG, nous remarquons que la majorité d'entre eux (11/17) en connaissent plusieurs.}
\label{fig:QNbFilt}
\end{figure}

\begin{figure}[!ht]
\centering
\includegraphics[scale=0.8]{figures/QTravFilt.png}
\caption{Question 7) [Données filtrées] Pourcentage des répondants ayant déjà travaillé avec une BDOG.}
\label{fig:QTravFilt}
\end{figure}

\vspace*{\stretch{1}}
\newpage
\vspace*{\stretch{1}}

\begin{figure}[!ht]
\centering
\includegraphics[scale=1]{figures/QLibJavaFilt.png}
\caption{Question 8) [Données filtrées] Seuls 24\% des répondants connaissent la manière de faire interagir du code Java et des BDOG. Cette réponse nous conforte dans le développement d'une solution simple qui leur permettrait, grâce à Archipelago, d'accéder directement à la BDOG sans passer par l'apprentissage des librairies spécifiques.}
\label{fig:QLibJavaFilt}
\end{figure}

\begin{figure}[!ht]
\centering
\includegraphics[scale=0.8]{figures/QFrameworkIntFilt.png}
\caption{Question 9) [Données filtrées] Cette réponse nous conforte à nouveau dans l'idée qu'une place est à prendre pour le développement d'Archipelago.}
\label{fig:QFrameworkIntFilt}
\end{figure}

\vspace*{\stretch{1}}
\newpage
\vspace*{\stretch{1}}

\begin{figure}[!ht]
\centering
\includegraphics[scale=0.8]{figures/QAbanFilt.png}
\caption{Malgré la promesse d'un outil fiable, cette réponse témoigne essentiellement de la difficulté de changer les habitudes de développement.}
\label{fig:QAbanFilt}
\end{figure}



\subsection{Contenu qualitatif}
Nous avons décidé d'analyser la manière dont les répondants comprennent les bouts de codes utilisant le framework Archipelago. Nous ne leur avons fourni aucune documentation préalable. En légende des bouts de code ci-après, nous indiquerons le pourcentage de répondants ayant parfaitement compris la fonctionnalité que nous avons voulu préconiser (BR\footnote{\textbf{B}onne \textbf{R}éponse}), le pourcentage de personnes qui n'en ont pas saisi toutes les subtilités (MR\footnote{\textbf{M}oyenne \textbf{R}éponse}), et enfin
le pourcentage de celles qui n'ont pas compris du tout (PC\footnote{\textbf{P}as \textbf{C}ompris}).

En règle générale, nous avons été agréablement surpris par les bonnes réponses des répondants, nous pouvons supposer que l'utilisation du framework est simple car nous obtenons une moyenne de bonnes réponses de l'ordre de 78\%. Le questionnaire se terminait par une possibilité de nous fournir un commentaire, nous permettant d'entrevoir plusieurs pistes d'amélioration.

\vspace*{\stretch{1}}
\newpage
\vspace*{\stretch{1}}
\begin{figure}[!ht]
\centering
\includegraphics[scale=0.9]{figures/Snippet1.png}
\caption{Bout de code permettant d'instancier un objet de type City et de le persister dans la BDOG:\\BR : 80\% MR : 4\% PC : 16\% }
\label{fig:Snippet1}
\end{figure}

\begin{figure}[!ht]
\centering
\includegraphics[scale=0.9]{figures/Snippet2.png}
\caption{Bout de code permettant de lier deux nœuds à l'aide d'un objet de type Road dans la BDOG:\\BR : 84\% MR : 0\% PC : 16\% }
\label{fig:Snippet2}
\end{figure}

\vspace*{\stretch{1}}
\newpage

\vspace*{\stretch{1}}
\begin{figure}[!ht]
\centering
\includegraphics[scale=0.9]{figures/Snippet3.png}
\caption{Bout de code permettant de faire une requête dans la base de données en recherchant toutes les instances de villes se nommant \enquote{King's Landing} (Nous avons accepté les réponses désignant \enquote{La ville de King's Landing} comme étant une bonne réponse):\\BR : 76\% MR : 4\% PC : 20\% }
\label{fig:Snippet3}
\end{figure}

\begin{figure}[!ht]
\centering
\includegraphics[scale=0.9]{figures/Snippet4.png}
\caption{Bout de code permettant de faire une reqête dans la base de données en recherchant toutes les instances de villes se nommant \enquote{King's Landing} OU \enquote{Winterfell} ET NON \enquote{Dragonstone}:\\BR : 72\% MR : 4\% PC : 24\% }
\label{fig:Snippet4}
\end{figure}

\vspace*{\stretch{1}}
\chapter{Conclusion}

Archipelago est un framework dont le but est d'abstraire l'utilisation d'une BDOG orientée graphe. 

Le but de ce travail est de permettre à l'utilisateur de se centrer sur la représentation du modèle ainsi que sur le traitement métier de celui-ci sans perdre du temps à implémenter la couche de persistance. L'état actuel du développement de ce framework peut être considéré comme un \enquote{POC}.

Certaines fonctionnalités ont d'ores et déjà été implémentées telles que la persistance, la liaison et la récupération.

Comme signalé ci-dessus, nous pouvons reprendre les points forts de ce framework, à savoir :

\begin{itemize}
\item \textbf{La facilité}

\quad La facilité d'enregistrement d'informations pouvant être fortement interconnectées dans des BDOG ainsi que le marquage des sommets.

\item \textbf{La configurabilité}

\quad Une aide à la récupération d'un certain nombre de paramètres depuis un fichier de configuration permet de changer le comportement du framework ainsi que d'ajouter ou d'ôter aisément de nouveaux paramètres, en fonction des améliorations futures.

\item \textbf{L'abstraction}

\quad L'utilisateur ne doit se soucier d'aucune mise en œuvre spécifique à la base de données ciblée. 

\item \textbf{La simplification}

\quad Ce framework permet de réutiliser n'importe quel code existant. Il suffit alors à l'utilisateur d'ajouter les annotations \texttt{@Bridge} pour que son code soit compatible avec son application.

\item \textbf{La modularité}

\quad Le genre d'architecture utilisé pour développer ce framework offre une maintenance aisée car il permet de concentrer la recherche de problèmes dans un espace défini et bien cadré.

\end{itemize}
\newpage
Les points à améliorer quant à eux sont :


\begin{itemize}
\item \textbf{Les performances}

\quad Bien que nous ayons essayé d'améliorer ce point grâce au marquage des sommets, nous n'avons pas eu le temps d'approfondir ce procédé avec un marquage des arêtes.

\item \textbf{Les conditions}

\quad Notre framework possède trois faiblesses principales en ce qui concerne la manière avec laquelle nous pouvons récupérer de l'information.
\begin{itemize}
	\item[•] \underline{Sous-conditions :} nous pouvons actuellement générer des conditions simples. Pour créer des conditions plus complexes, il faudrait effectuer une refonte du système d'imbrication afin de permettre à l'utilisateur de créer des sous-conditions. 
	\item[•] \underline{Conditions sur les relations :} l'impossibilité de produire une condition sur une relation entre deux nœuds.
	\item[•] \underline{Conditions sur les éléments liés :} actuellement, l'ensemble des conditions s'applique sur le nœud principal de la requête. Il nous est impossible de filtrer les éléments qui vont être liés avec celui-ci. Nous sommes dès lors exposés à des problèmes de charge si le nœud principal est lié à plusieurs millions d'autres.
\end{itemize}

\item \textbf{La récupération d'informations}

\quad Il n'existe pas encore de procédé permettant de récupérer des informations sur une relation entre deux nœuds dans un objet Java. Les  liaisons internes dans un objet seront récupérées mais nous ne bénéficierons pas de toutes les informations fournies lors de la persistance.

\item \textbf{La propreté du code}

\quad tel que signalé dans la section \ref{propreteDuCode}, l'implémentation de ce framework pourrait être améliorée si l'on disposait de temps supplémentaire pour en évacuer les morceaux de codes inutiles. En outre, il serait primordial d'y insérer des tests unitaires afin de s'assurer du bon fonctionnement de chacune des méthodes implémentées.

\end{itemize}  

L'ensemble de ces points faibles a été pris en considération durant le développement de ce framework. Nous vous proposons dès lors des pistes d'améliorations réalistes telles que : 
\begin{enumerate}
\item Amélioration du système de conditions
\item Amélioration des performances
\item Amélioration de l'exploitation des relations
\item Ajout d'algorithmes célèbres de théorie des graphes
\end{enumerate}
 
Et nous les développerons dans le chapitre \ref{perspectives} de ce travail.

Si l'approche d'une mise en place d'un standard commun aux BDOG semblait intéressante en soi, elle irait apparemment à l'encontre même de ces systèmes. Même si Gremlin et OpenCypher sont en voie de s'imposer vu leur importance dans l'univers des BDOG, la plupart des leurs promoteurs souhaitent les considérer comme des bases de données spécialisées.

La solution proposée par ce mémoire permet quant à elle, d'abstraire les différentes implémentations, standardisées ou non, et constituerait une approche unifiée pour l'univers des développeurs Java.

\chapter{Perspectives}

Il nous semblait plus pertinent de scinder les perspectives d'améliorations de ce mémoire, des conclusions. A ce propos, nous dressons donc un ensemble de pistes auxquelles nous avons pensé mais que, pour diverses raisons, nous n'avons pu mettre en place actuellement. Ces éléments pourront contribuer au \enquote{cahier des charges} ou être une piste de réflexion pour une éventuelle deuxième version de ce framework.

\label{perspectives}
\section{Amélioration des performances}

Le premier effort, afin d'améliorer les performances, serait d'effectuer le marquage des arêtes.

Les algorithmes existants de la théorie des graphes nous permettraient d'améliorer le parcours du graphe généré par les relations entre les différents objets du modèle\cite{solnontheorie}. 

\section{Amélioration du système de conditions}

Pour améliorer le système de conditions, il est primordial de retravailler la manière dont les conditions sont implémentées. Pour l'avenir de ce projet, il faut que l'utilisateur soit en mesure d'émettre des conditions sur les relations ainsi que sur les éléments liés.

Sur base du questionnaire\footnote{Mettre en place un système tel que réalisé par \enquote{Hibernate} avec l'implémentation de leur \texttt{Criterion}.} que nous avons soumis, une idée de modification est apparue dans les suggestions et nous a particulièrement convaincu. 

Le système pourrait être revu de la manière suivante : 

\begin{lstlisting}
// Instanciation du framework
Archipelago arch = Archipelago.getInstance();
// Création de la requête
ArchipelagoQuery aq = arch.getQueryBuilder()  
// Spécification du type d'élément
    .of(City.class) 						  
// Création de condition
    .where(									  
// Début de _1_ET_2_
    	  and( 							      
// Première partie du ET(1) et début de _1_OU_2_
              or(							  
// Condition d'équivalence "name" = "King's Landing" dans OU(1)
      	          eq("name","King's Landing"),
// Condition d'équivalence "name" = "Winterfell" dans OU(2)
    	          eq("name","Winterfell")     
    	        ),
// Condition de non-équivalence "name" <> "Dragonstone" dans ET(2)
    	      neq("name","Dragonstone")       
    	      ),
// Condition de positionnement : Nœud de départ
    	   ArchipelagoPosition.START          
    	  )
// Création de requête
    .where(     
// Début de _1_ET_2_                                  
          and(        
// Condition de grandeur "distance" >= 300 dans ET(1)                                 
      	        gt("distance",300),
// Condition d'équivalence "unit" = leagues" dans ET(2)           
    	        eq("unit","leagues")          
    	       ),
// Condition de positionnement : relation
    	   ArchipelagoPosition.EDGE           
    	  )
// Création de requête
    .where(
// Condition d'équivalence "name" = Winterfell"
          eq("name","Winterfell"),
// Condition de positionnement : relation
    	  ArchipelagoPosition.END
    	  )
// Génération de la requête
    .build();
// Exécution de la requête
List<Object> nodes = arch.execute(aq);

\end{lstlisting} 
Avec le procédé décrit par les commentaires, chaque condition peut être imbriquée dans une autre sous-condition. Nous avons dès lors grâce à cette implémentation, la possibilité d'effectuer toutes les conditions logiques possibles sur le nœud de départ, sur l'arête ainsi que sur le nœud d'arrivée.

Si le framework rendait possible l'utilisation d'un langage de condition simple avec une analyse de requête (parsing), cette deuxième solution permettrait quant à elle de simplifier grandement les conditions courantes. Une grammaire BNF\footnote{\url{http://matt.might.net/articles/grammars-bnf-ebnf/}} comme suit serait intéressante à implémenter :

\begin{lstlisting}
condition ::=
	token
	| '(' token ('AND'|'OR') token ')';
token ::= expr symbol value 'ON' position ;
position ::= ('START' | 'EDGE' | 'END') ;
symbol ::= ('='|'!='|'>'|'>='|'<'|'<=') ;
expr ::= '"'[a-zA-Z0-9]+'"' ;
value ::= '"'[a-zA-Z0-9]+'"'| [0-9]+ ;
\end{lstlisting}

\section{Amélioration de l'exploitation des relations}

Un objet générique "Wrapper" tel que présenté dans la section \ref{frameworksAnalyse}, représentant un lien entre deux objets, peut être une piste d'amélioration de l'exploitation des relations. Comme la librairie de Neo4J le fait, la récupération d'information s'effectue entre autres, dans un objet contenant 3 propriétés intéressantes :

\begin{tabular}[c]{l M{12cm}}
\texttt{start} & L'objet de départ.  \tabularnewline
\texttt{relation} & L'objet comprenant les informations de relation.  \tabularnewline
\texttt{end} & L'objet d'arrivée.  \tabularnewline
\end{tabular}

Grâce à cette représentation, nous serons en mesure d'effectuer un grand nombre d'instructions sur ces relations essentielles dans l'utilisation d'une base de données orientée graphe.

\section{Ajout d'algorithmes célèbres de la théorie des graphes}

\subsection*{Plus court chemin}

L'utilisation des BDOG est entre autres un choix pris pour effectuer des recherches de proximité entre deux éléments de la base de données. Ces algorithmes sont souvent déjà implémentés du côté des BDOG mêmes. Il faudrait dès lors qu'Archipelago implémente une nouvelle fonction permettant d'appeler ces algorithmes tels que le très célèbre \enquote{Dijkstra}\cite{dijkstra1959note}. 

Exemple : 

\begin{lstlisting}
Archipelago arch = Archipelago.getInstance();

// Initialisation de la requête
ArchipelagoQuery aq = arch.getQueryBuilder()
// Spécification du type de départ
    .from(City.class)
// Conditions voir exemples précédents     
    	.where(
    	   ... ,
    	   ArchipelagoPosition.START
    	  )
// Spécification du type d'arrivée
    .to(City.class)
// Conditions voir exemples précédents  
    	.where(
    	   ...,
    	   ArchipelagoPosition.END
    	  )
// Spécification de l'algorithme de recherche de parcours
    .with(ArchipelagoAlgo.DIJKSTRA)
// Génération de la requête
    .build();
List<Object> nodes = arch.execute(aq);
\end{lstlisting}


\subsection*{Problème du voyageur de commerce}

Le problème du voyageur de commerce est un problème d'optimisation visant à lier un ensemble de nœuds en formant le plus court chemin entre ceux-ci.

Une implémentation d'une heuristique telle que par exemple l'ACS\cite{dorigo1997ant} peut être une fonctionnalité intéressante pour une seconde version de ce framework. En effet, si l'utilisateur a la possibilité d'employer ce genre d'algorithme pour résoudre ce type de problème, Archipelago répondra plus facilement aux attentes d'applications logistiques.



\bibliography{biblio} 

\part{Annexes}
\section*{1. diagramme de classe \enquote{l'école}}

\begin{figure}[!ht]
	\centering
    \includegraphics[angle=90,origin=c,scale=0.8]{figures/SchoolDiag.png}
    \caption{Diagramme de Classe du modèle École.}
    \label{fig:SchoolDiagram}
\end{figure}

\section*{2. Création des objets composant l'école}

\begin{lstlisting}
private static School genSchool() throws ClassNotFoundException, IOException {

    Lesson math8 = new Lesson("Math", 8l);
    Lesson math6 = new Lesson("Math", 6l);
    Lesson math4 = new Lesson("Math", 4l);
    Lesson science6 = new Lesson("Science", 6l);
    Lesson science3 = new Lesson("Science", 3l);
    Lesson frans5 = new Lesson("Frans", 5l);
    Lesson frans6 = new Lesson("Frans", 6l);
    Lesson dutch2 = new Lesson("Dutch", 2l);
    Lesson dutch4 = new Lesson("Dutch", 4l);
    Lesson english2 = new Lesson("English", 2l);
    Lesson english4 = new Lesson("English", 4l);
    Lesson history = new Lesson("History", 2l);
    Lesson geography = new Lesson("Geography", 2l);
    Lesson religion = new Lesson("Religion", 2l);
    Lesson pE = new Lesson("Physical Education", 2l);
    Lesson greek = new Lesson("Greek ancient", 4l);
    Promotion p2011 = new Promotion(2011);
    Promotion p2002 = new Promotion(2002);
    Promotion p2010 = new Promotion(2010);
    Teacher gys = new Teacher("Hans", "Gys", null, "M", Lists.newArrayList(dutch2, dutch4, english2, english4), Lists.newArrayList(dutch2, dutch4,english2, english4), "Master");
    Teacher goffin = new Teacher("Michel", "Goffin", null, "M", Lists.newArrayList(math8, math6, math4), Lists.newArrayList(math8, math6, math4), "Master");
    Teacher massart = new Teacher("Gabriel", "Massart", null, "M", Lists.newArrayList(math8, math6, math4), Lists.newArrayList(math8, math6, math4), "Master");
    Teacher gouthers = new Teacher("Yves", "Gouthers", null, "M", Lists.newArrayList(frans5, frans6, religion), Lists.newArrayList(frans5, frans6, religion), "Master");
    Teacher jacques = new Teacher("Christian", "Jacques", null, "M", Lists.newArrayList(geography), Lists.newArrayList(geography), "Master");
    Student gilles = new Student("Gilles", "Bodart", LocalDate.of(1992, 4, 14), "M", Lists.newArrayList(math8, science6, dutch2, english4, history, geography, religion, frans5, pE), null, null, p2011);
    Student thomasB = new Student("Thomas", "Blondiau", LocalDate.of(1992, 1, 5), "M", Lists.newArrayList(math8, science3, dutch2, english4, history, geography, religion, frans5, pE, greek), null, null, p2010);
    Student thomasR = new Student("Thomas", "Reynders", LocalDate.of(1992, 1, 22), "M", Lists.newArrayList(math8, science6, dutch2, english4, history, geography, religion, frans5, pE), null, null, p2010);
    Student charly = new Student("Charles-Antoine", "Van Beers", LocalDate.of(1992, 4, 28), "M", Lists.newArrayList(math8, science3, dutch2, english4, history, geography, religion, frans5, pE, greek), null, null, p2010);
    Student antoine = new Student("Antoine", "Dumont", LocalDate.of(1992, 12, 28), "M", Lists.newArrayList(math6, science3, dutch4, english4, history, geography, religion, frans5, pE, greek), null, null, p2010);
    Student martin = new Student("Martin", "Périlleux", LocalDate.of(1992, 2, 28), "M", Lists.newArrayList(math6, science3, dutch4, english4, history, geography, religion, frans5, pE, greek), null, null, p2010);
    Student benjamin = new Student("Benjamin", "Leroy", LocalDate.of(1992, 10, 31), "M", Lists.newArrayList(math8, science3, dutch2, english4, history, geography, religion, frans5, pE, greek), null, null, p2010);
    Student antoineBo = new Student("Antoine", "Bodart", LocalDate.of(1985, 10, 18), "M", Lists.newArrayList(math6, science6, dutch2, english4, history, geography, religion, frans5, pE), null, null, p2002);
    Worker cassart = new Worker("", "Cassart", null, "M", null, null);
    List<Room> rooms;
    Room library = new org.archipelago.test.domain.school.Library("Library", Lists.newArrayList("Le livre du voyage", "Le tour du monde en 80 jours", "La nuit des enfants roi", "Le joueur d'échecs"), cassart);
    cassart.setInChargeOf(Lists.newArrayList(library));
    Room l003 = new ClassRoom("L003", 30, true, false, true);
    Room c203 = new ClassRoom("C203", 30, true, false, true);
    Room l306 = new ClassRoom("L306", 50, true, true, false);
    gilles.setFriends(Lists.newArrayList(thomasB, thomasR, charly, antoine, martin, benjamin, antoineBo));
    gilles.setFamilyMember(Lists.newArrayList(antoineBo));
    thomasB.setFriends(Lists.newArrayList(gilles, thomasR, charly, antoine, martin, benjamin));
    thomasR.setFriends(Lists.newArrayList(thomasB, gilles, charly, antoine, martin, benjamin));
    charly.setFriends(Lists.newArrayList(thomasB, thomasR, gilles, antoine, martin, benjamin));
    antoine.setFriends(Lists.newArrayList(thomasB, thomasR, charly, gilles, martin, benjamin));
    martin.setFriends(Lists.newArrayList(thomasB, thomasR, charly, antoine, gilles, benjamin));
    benjamin.setFriends(Lists.newArrayList(thomasB, thomasR, charly, antoine, martin, gilles));
    School school = new School();
    school.setName("Saint Louis Namur");
    school.setDirector(gys);
    school.setTeachers(Lists.newArrayList(goffin, gouthers, jacques, gys, massart));
    school.setStudents(Lists.newArrayList(gilles, thomasB, thomasR, charly, antoine, martin, benjamin, antoineBo));
    school.setRooms(Lists.newArrayList(library, l003, l306, c203));
    school.setWorkers(Lists.newArrayList(cassart));
    return school;
    }
\end{lstlisting}
\label{SchoolObj}
\section*{Les résultats du questionnaire}
Les résultats non filtrés du questionnaire se trouvent dans un fichier CSV (\texttt{Archipelago Questionnaire.csv}), inclus dans la sauvegarde numérique de ce mémoire.

Voici un export brut des images d'analyses générées par Google{\mbox{\scriptsize{\copyright}}} Form :

\begin{figure}[htp]
\centering
    \includegraphics[width=.45\textwidth]{figures/1.png}\quad
    \includegraphics[width=.45\textwidth]{figures/2.png}
\end{figure}
\begin{figure}[htp]
\centering
    \includegraphics[width=.45\textwidth]{figures/3.png}\quad
    \includegraphics[width=.45\textwidth]{figures/4.png}
\end{figure}
\begin{figure}[htp]
\centering
    \includegraphics[width=.45\textwidth]{figures/5.png}\quad
    \includegraphics[width=.45\textwidth]{figures/6.png}
\end{figure}
\begin{figure}[htp]
\centering
    \includegraphics[width=.45\textwidth]{figures/7.png}\quad
    \includegraphics[width=.45\textwidth]{figures/8.png}
\end{figure}
\begin{figure}[htp]
\centering
    \includegraphics[width=.45\textwidth]{figures/9.png}\quad
    \includegraphics[width=.45\textwidth]{figures/10.png}
\end{figure}
\begin{figure}[htp]
\centering
    \includegraphics[width=.45\textwidth]{figures/11.png}\quad
    \includegraphics[width=.45\textwidth]{figures/12.png}
\end{figure}


\chapter*{Code Source}

Par souci d'écologie et par praticité, notre code est disponible sur le dépot GitHub (cf. lien ci-dessous) ainsi que sur la copie numérique de ce mémoire.

 \url{https://github.com/GillesBodart/Archipelago}. 
%\include{./cdSource}

 

\end{document}
